#include "fabm_driver.h"
#ifdef _FABM_F2003_
! --------------------------------------------
! Size- & distribution based ctenophore model
! kai wirtz Apr 2014
! --------------------------------------------
module fabm_hzg_jelly
!
! !USES:
  use fabm_types
  use fabm_driver
  implicit none

 !public flags for communication with fabm-driver/time-loop
  !character(len=80),   public      ::  jelly_timestr
  !integer,             public      ::  OutJellyRGR, CalcJellyRGR
  public grazkinetics

  private
 ! HZG model types
  !type type_diff
  ! real(rk) :: mu, dmudl, d2mudl2, dmudV, dsinkdl, dsinkdp, d2mudl2_d, dmu_d
  !end type
  integer   :: numb=2
  real(rk)  :: i13sig

!#SP0
!!----------------------------------------------------------------------
!! this code is generated by a parser  (conv_nml_fabm.c by kai wirtz)
!!----------------------------------------------------------------------
! --- HZG model types
type type_jelly_var
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be
 real(rk) :: Cop,Temp,salt
end type
type type_jelly_rhs
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be
end type
! standard fabm model types
type,extends(type_base_model),public :: type_hzg_jelly
type (type_state_variable_id), dimension(2) :: id_B_Pp,id_l_Pp,id_B_Be,id_l_Be
type (type_dependency_id)            :: id_Cop
type (type_dependency_id)            :: id_Temp
type (type_dependency_id)            :: id_salt
type (type_diagnostic_variable_id)   :: id_prod_Be, id_Mort_Be, id_fA_Be, id_Imax_Be, id_prod_Pp, id_Mort_Pp, id_fA_Pp, id_Imax_Pp, id_mort_S, id_mort_R, id_mort_G, id_somgrowth, id_recruit, id_som_lshift, id_init_lshift, id_graz_lshift, id_sen_lshift, id_prod_lshift, id_dl_prey, id_dl_pred, id_al_Im, id_mixBmass, id_mixlsize, id_Tdep
real(rk) ::  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial
real(rk) ::  lA, l0, sigma, Imax_pot, yield, mR, mS, Q10, Tc, Bcrit, relCVDens, m_predBe, loptA_Pp, loptA_Be, rgelC, immigr, dil_CH, dil_HO, relV_O
real(rk) ::  eps
logical  ::  TransectOn, SizeDynOn, LowPassOn, OptionOn

contains
!   Model procedures
procedure :: initialize
procedure :: do
procedure :: mixing
procedure :: errfunc
end type type_hzg_jelly

!
! !PRIVATE DATA MEMBERS:
 real(rk), parameter :: secs_pr_day = 86400.0_rk
!EOP
!!--------------------------------------------------------------------

contains
! !IROUTINE: Initialise the jelly model
!
! !INTERFACE:
subroutine initialize(self, configunit)
! !DESCRIPTION:
!  Here, the namelists are read and the variables exported
!  by the model are registered with FABM.
!
! !INPUT PARAMETERS:
class (type_hzg_jelly), intent(inout), target :: self
integer,                  intent(in)            :: configunit
!
! !LOCAL VARIABLES:
integer    :: namlst=19
!!------- Initial values of model jelly ------- 
!> \describepar{B_Pp_initial , B_\mathrm{Pp} , P.Pileus biomass, 0.02 µg-C/L}
!> \describepar{l_Pp_initial , \ell_\mathrm{Pp} , P.Pileus mean log size, 1.8 mm}
!> \describepar{B_Be_initial , B_\mathrm{Be} , Beroe biomass, 0.01 µg-C/L}
!> \describepar{l_Be_initial , \ell_\mathrm{Be} , Beroe mean log size, 2.1 mm}
real(rk)  :: B_Pp_initial ! P.Pileus biomass
real(rk)  :: l_Pp_initial ! P.Pileus mean log size
real(rk)  :: B_Be_initial ! Beroe biomass
real(rk)  :: l_Be_initial ! Beroe mean log size
!> describepar{lA           , \ell_A           , adult ctenophore size        , 2. log(ESD/mm)}
!> describepar{l0           , \ell_0           , offspring size, -1. log(ESD/mm)}
!> describepar{sigma        , \sigma        , std deviation of juvenile size, 0.4 log(ESD/mm)^2}
!> describepar{Imax_pot     , I_\mathrm{max}^*     , maximum ingestion rate for ideal consumer, prey, T, and food , 173. 1/d}
!> describepar{yield        , y        , feeding yield , 0.5 }
!> describepar{mR           , m_R           , temperature dependent, natural mortality rate , 0.12 1/d}
!> describepar{mS           , m_S           , physiological mortality under senescence , 0.04 1/d}
!> describepar{Q10          , Q_{10}          , rate increase at 10C temperature rise, 3. }
!> describepar{Tc           , T_c           , critical threshold temperature, 4. }
!> describepar{Bcrit        , B^*        , minimal prey biomass (Holling-III) , 1.5 µg-C/L}
!> describepar{relCVDens    , R_\rho    , C-biovolume density ratio non-gelatinous/gelatinous plankton, 70. µg-C/L}
!> describepar{m_predBe     , B_\mathrm{TP}     , loss rate of Beroe due to top-predator , 0.0 1/d}
!> describepar{loptA_Pp     , \lcsize_\mathrm{opt,Pp}^A     , optimal prey size adult P.pileus , -1.0 }
!> describepar{loptA_Be     , \lcsize_\mathrm{opt,Be}^A     , optimal prey size adult Beroe , 1.6 }
!> describepar{rgelC        , R_{\rho C}        , C-density ratio in gelatinous plankton , 3.0 }
!> describepar{immigr       , \epsilon_\mathrm{in}       , migration mass inflow rate , 0.000002 µg-C/L.d}
!> describepar{dil_CH       ,        , Exchange rate Coast-HR, 0.35 1/d}
!> describepar{dil_HO       ,        , Exchange rate HR-Offshore, 0.1 1/d}
!> describepar{relV_O       ,        , relative volume Offshore box, 10. 1/d}
!> describepar{eps          ,           , minimal offset for juvenile p.pileus biomass, 1E-4 }
!!------- Parameters from nml-list jelly_pars ------- 
real(rk)  :: lA           ! adult ctenophore size        
real(rk)  :: l0           ! offspring size
real(rk)  :: sigma        ! std deviation of juvenile size
real(rk)  :: Imax_pot     ! maximum ingestion rate for ideal consumer, prey, T, and food 
real(rk)  :: yield        ! feeding yield 
real(rk)  :: mR           ! temperature dependent, natural mortality rate 
real(rk)  :: mS           ! physiological mortality under senescence 
real(rk)  :: Q10          ! rate increase at 10C temperature rise
real(rk)  :: Tc           ! critical threshold temperature
real(rk)  :: Bcrit        ! minimal prey biomass (Holling-III) 
real(rk)  :: relCVDens    ! C-biovolume density ratio non-gelatinous/gelatinous plankton
real(rk)  :: m_predBe     ! loss rate of Beroe due to top-predator 
real(rk)  :: loptA_Pp     ! optimal prey size adult P.pileus 
real(rk)  :: loptA_Be     ! optimal prey size adult Beroe 
real(rk)  :: rgelC        ! C-density ratio in gelatinous plankton 
real(rk)  :: immigr       ! migration mass inflow rate 
real(rk)  :: dil_CH       ! Exchange rate Coast-HR
real(rk)  :: dil_HO       ! Exchange rate HR-Offshore
real(rk)  :: relV_O       ! relative volume Offshore box
!!------- Parameters from nml-list jelly_ctl ------- 
real(rk)  :: eps          ! minimal offset for juvenile p.pileus biomass
!!------- Switches for configuring model structure -------
logical   :: TransectOn   ! mixing between coastal transect boxes
logical   :: SizeDynOn    ! life stage cycling enabled
logical   :: LowPassOn    ! filter high frequency in forcing
logical   :: OptionOn     ! generic
character(len=64)   :: sbname,cbname
integer   :: ib

namelist /jelly_init/ &
  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial

namelist /jelly_pars/ &
  lA, l0, sigma, Imax_pot, yield, mR, mS, Q10, Tc, Bcrit, relCVDens, m_predBe, loptA_Pp, &
  loptA_Be, rgelC, immigr, dil_CH, dil_HO, relV_O

namelist /jelly_ctl/ &
  eps

namelist /jelly_switch/ &
  TransectOn, SizeDynOn, LowPassOn, OptionOn

B_Pp_initial = 0.02_rk            ! µg-C/L
l_Pp_initial = 1.8_rk             ! mm
B_Be_initial = 0.01_rk            ! µg-C/L
l_Be_initial = 2.1_rk             ! mm
lA           = 2._rk              ! log(ESD/mm)
l0           = -1._rk             ! log(ESD/mm)
sigma        = 0.4_rk             ! log(ESD/mm)^2
Imax_pot     = 173._rk            ! 1/d
yield        = 0.5_rk             ! 
mR           = 0.12_rk            ! 1/d
mS           = 0.04_rk            ! 1/d
Q10          = 3._rk              ! 
Tc           = 4._rk              ! 
Bcrit        = 1.5_rk             ! µg-C/L
relCVDens    = 70._rk             ! µg-C/L
m_predBe     = 0.0_rk             ! 1/d
loptA_Pp     = -1.0_rk            ! 
loptA_Be     = 1.6_rk             ! 
rgelC        = 3.0_rk             ! 
immigr       = 0.000002_rk        ! µg-C/L.d
dil_CH       = 0.35_rk            ! 1/d
dil_HO       = 0.1_rk             ! 1/d
relV_O       = 10._rk             ! 1/d
eps          = 1E-4_rk            ! 


!--------- read namelists --------- 
write(0,*) ' read namelists ....'
open(namlst,file='jelly_init.nml',status='old')
read(namlst,nml=jelly_init,err=90,end=99)
open(namlst,file='jelly_pars.nml',status='old')
read(namlst,nml=jelly_pars,err=91,end=100)
open(namlst,file='jelly_ctl.nml',status='old')
read(namlst,nml=jelly_ctl,err=92,end=101)
open(namlst,file='jelly_switch.nml',status='old')
read(namlst,nml=jelly_switch,err=93,end=102)
! Store parameter values in our own derived type
! NB: all rates must be provided in values per day,
! and are converted here to values per second.

!!------- logical parameters: switches  -------
call self%get_parameter(self%TransectOn,    'TransectOn',    default=TransectOn)
call self%get_parameter(self%SizeDynOn,     'SizeDynOn',     default=SizeDynOn)
call self%get_parameter(self%LowPassOn,     'LowPassOn',     default=LowPassOn)
call self%get_parameter(self%OptionOn,      'OptionOn',      default=OptionOn)

!!------- model parameters from nml-list jelly_init ------- 
call self%get_parameter(self%B_Pp_initial ,'B_Pp_initial',  default=B_Pp_initial)
call self%get_parameter(self%l_Pp_initial ,'l_Pp_initial',  default=l_Pp_initial)
call self%get_parameter(self%B_Be_initial ,'B_Be_initial',  default=B_Be_initial)
call self%get_parameter(self%l_Be_initial ,'l_Be_initial',  default=l_Be_initial)

!!------- model parameters from nml-list jelly_pars ------- 
call self%get_parameter(self%lA           ,'lA',            default=lA)
call self%get_parameter(self%l0           ,'l0',            default=l0)
call self%get_parameter(self%sigma        ,'sigma',         default=sigma)
call self%get_parameter(self%Imax_pot     ,'Imax_pot',      default=Imax_pot)
call self%get_parameter(self%yield        ,'yield',         default=yield)
call self%get_parameter(self%mR           ,'mR',            default=mR)
call self%get_parameter(self%mS           ,'mS',            default=mS)
call self%get_parameter(self%Q10          ,'Q10',           default=Q10)
call self%get_parameter(self%Tc           ,'Tc',            default=Tc)
call self%get_parameter(self%Bcrit        ,'Bcrit',         default=Bcrit)
call self%get_parameter(self%relCVDens    ,'relCVDens',     default=relCVDens)
call self%get_parameter(self%m_predBe     ,'m_predBe',      default=m_predBe)
call self%get_parameter(self%loptA_Pp     ,'loptA_Pp',      default=loptA_Pp)
call self%get_parameter(self%loptA_Be     ,'loptA_Be',      default=loptA_Be)
call self%get_parameter(self%rgelC        ,'rgelC',         default=rgelC)
call self%get_parameter(self%immigr       ,'immigr',        default=immigr)
call self%get_parameter(self%dil_CH       ,'dil_CH',        default=dil_CH)
call self%get_parameter(self%dil_HO       ,'dil_HO',        default=dil_HO)
call self%get_parameter(self%relV_O       ,'relV_O',        default=relV_O)

!!------- model parameters from nml-list jelly_ctl ------- 
call self%get_parameter(self%eps          ,'eps',           default=eps)

!!------- Register state variables  ------- 
do ib = 1, 2
write (sbname, "(A,I1)") 'B_Pp',ib 
cbname = 'P.Pileus biomass ' // sbname
call self%register_state_variable(self%id_B_Pp(ib),sbname,'µg-C/L',cbname, &
   B_Pp_initial, minimum=_ZERO_, no_river_dilution=.true. )
write (sbname, "(A,I1)") 'l_Pp',ib 
cbname = 'P.Pileus mean log size ' // sbname
call self%register_state_variable(self%id_l_Pp(ib),sbname,'mm',cbname, &
   l_Pp_initial, minimum=-2.0d0, no_river_dilution=.true. )
write (sbname, "(A,I1)") 'B_Be',ib 
cbname = 'Beroe biomass ' // sbname
call self%register_state_variable(self%id_B_Be(ib),sbname,'µg-C/L',cbname, &
   B_Be_initial, minimum=_ZERO_, no_river_dilution=.true. )
write (sbname, "(A,I1)") 'l_Be',ib 
cbname = 'Beroe mean log size ' // sbname
call self%register_state_variable(self%id_l_Be(ib),sbname,'mm',cbname, &
   l_Be_initial, minimum=-2.0d0, no_river_dilution=.true. )
end do

!!------- Register diagnostic variables  ------- 
call self%register_diagnostic_variable(self%id_prod_Be, 'prod_Be','1/d', 'secondary production rate Beroe prod_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Be, 'Mort_Be','1/d', 'mortality rate of Beroe Mort_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Be,   'fA_Be','1/d', 'relative propotion adults Beroe fA_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Be, 'Imax_Be','1/d', 'maximum ingestion rate adult Beroe Imax_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_Pp, 'prod_Pp','1/d', 'secondary production rate P pileus prod_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Pp, 'Mort_Pp','1/d', 'mortality rate of P pileus Mort_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Pp,   'fA_Pp','1/d', 'relative propotion adults P pileus fA_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Pp, 'Imax_Pp','1/d', 'maximum ingestion rate adult Beroe Imax_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_S,  'mort_S','1/d', 'physiological adult mortality rate mort_S', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_R,  'mort_R','1/d', 'temperature dependent mortality mort_R', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_G,  'mort_G','1/d', 'top-predation mort_G', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_somgrowth, 'somgrowth','1/d', 'somatic growth rate  somgrowth', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_recruit, 'recruit','1/d', 'egg production rate  recruit', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_som_lshift, 'som_lshift','1/d', 'marginal size shift due to promotion som_lshift', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_init_lshift, 'init_lshift','1/d', 'marginal size shift due to egg production init_lshift', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_graz_lshift, 'graz_lshift','1/d', 'marginal size shift due to selective grazing graz_lshift', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_sen_lshift, 'sen_lshift','1/d', 'marginal size shift due to starvation  sen_lshift', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_lshift, 'prod_lshift','1/d', 'marginal size shift due to production  prod_lshift', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_prey, 'dl_prey','1/d', 'size difference to prey  dl_prey', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_pred, 'dl_pred','1/d', 'size difference to pred  dl_pred', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_al_Im,   'al_Im','1/d', 'size scaling expoentent Imax  al_Im', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixBmass, 'mixBmass','1/d', 'mass exchange rate Coast-HR-Offshore mixBmass', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixlsize, 'mixlsize','1/d', 'trait exchange rate Coast-HR-Offshore mixlsize', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Tdep,    'Tdep','1/d', 'Temperature dependence Tdep', &
  output=output_instantaneous)

!!------- Register environmental dependencies  ------- 
call self%register_dependency(self%id_Cop,varname_par)
call self%register_dependency(self%id_Temp,varname_temp)
call self%register_dependency(self%id_salt,varname_salt)

! extra line included from parser var init_incl 
#define UNIT *1.1574074074E-5_rk

return

!!-------  if files are not found ...  
90 call self%fatal_error('jelly_init','Error reading namelist jelly_init.')
91 call self%fatal_error('jelly_init','Error reading namelist jelly_pars.')
92 call self%fatal_error('jelly_init','Error reading namelist jelly_ctl.')
93 call self%fatal_error('jelly_init','Error reading namelist jelly_switch.')
99 call self%fatal_error('jelly_init','Namelist jelly_init was not found in file.')
100 call self%fatal_error('jelly_init','Namelist jelly_pars was not found in file.')
101 call self%fatal_error('jelly_init','Namelist jelly_ctl was not found in file.')
102 call self%fatal_error('jelly_init','Namelist jelly_switch was not found in file.')

end subroutine initialize

!!----------------------------------------------------------------------
!!   end of section generated by parser 
!!----------------------------------------------------------------------
! #SP#"
!
!INTERFACE:
  subroutine do(self,_ARGUMENTS_DO_)
!
! !INPUT PARAMETERS:
  class (type_hzg_jelly),intent(in) :: self
  _DECLARE_ARGUMENTS_DO_
!
!LOCAL VARIABLES:

  type (type_jelly_var), dimension(3)       :: var
  type (type_jelly_rhs)       :: rhsv
  !type (type_diff)      :: diff,diff2
  !real(rk)              :: d2mudl2_d, dmu2=0.0_rk, mfac
!  type (type_environment),   intent(inout)  :: environment 
  real(rk) :: Temp_dep, Temp_dep0
  real(rk) :: mort_S, mort_S0, mort_R, mort_G, mort_J, mort_sum
  real(rk) :: errf, argA, eargA, aa, rS, eS, fS, al0, yfac
  real(rk) :: somgrwth, recruit,lco
  real(rk) :: prod_lshift, sum_lshift, resp_lshift
  real(rk) :: graz_lshift, som_lshift, init_lshift, sen_lshift
  real(rk), dimension(2,numb) :: dConc,dTrait
  real(rk), dimension(2) :: lmsize, dlp, dlopt,lopt, mass
  real(rk), dimension(2) :: mGPp, sig, sigma2, Imax, al1, f0
  real(rk) :: dl0, dl, dl2, bcrit, prey, preyE, dg_dlY2
  real(rk) :: fR, fA, fA0, dfA_dl, lm_adult, al, lprey, lcrit
  real(rk) :: gross, Graz, dg_dB0, dg_dB, dg_dlY,fdejuv
  integer  :: ib, ic, i
  real(rk) :: rg = 3.0
!  real(rk) :: inflow=2E-1, Adorm=2E-3

! !REVISION HISTORY:
!  Original author(s): Kai Wirtz, Nusret Sevinc

! !DESCRIPTION:
! Stage-based Pleurobrachia & Beroe Model
!
!EOP
!-----------------------------------------------------------------------
!BOC
! argA  = 0.5*(self%lA+self%l0)/(sqrt(2.d0)*self%sigma)
! call self%errfunc(argA, errf, eargA)
! relative fraction of adhults 
! fA0    = 0.5d0*(1.0d0 - errf) 

   ! Enter spatial loops (if any)
_FABM_LOOP_BEGIN_

! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb

!#S_GET
!---------- GET for each state variable ----------
  _GET_(self%id_B_Pp(ib), var(ib)%B_Pp)  ! P.Pileus biomass in µg-C/L
  _GET_(self%id_l_Pp(ib), var(ib)%l_Pp)  ! P.Pileus mean log size in mm
  _GET_(self%id_B_Be(ib), var(ib)%B_Be)  ! Beroe biomass in µg-C/L
  _GET_(self%id_l_Be(ib), var(ib)%l_Be)  ! Beroe mean log size in mm
!#E_GET
   ! Retrieve current environmental conditions.
!#S_GED
  _GET_(self%id_Cop, var(ib)%Cop)  ! biomass from Greve data-set
  _GET_(self%id_Temp, var(ib)%Temp)  ! temperature HR
  _GET_(self%id_salt, var(ib)%salt)  ! salinity HR
!#E_GED

 end do

!write (*,'(A,3(F10.3))') 'temp=',var(1)%Temp,var(2)%Temp,var(3)%Temp
! ib=1 HR   2: Coast  3:Offshore
! open water: less copepods, and reduced temperature fluctuation
!  var(2)%Cop  = 1.5 * var(2)%Cop
!  var(2)%Temp = -0.5 + 1.15*var(2)%Temp
 var(numb)%Cop  = 0.5 * var(numb)%Cop
 var(numb)%Temp = 2. + 0.8*var(numb)%Temp

 if(self%TransectOn) then
! exchange rate of mass HR-Offshore 
  call self%mixing(self%dil_HO, var(1)%B_Pp, self%relV_O,var(2)%B_Pp, dConc(1,1), dConc(1,2))
  call self%mixing(self%dil_HO, var(1)%B_Be, self%relV_O,var(2)%B_Be, dConc(2,1), dConc(2,2))

! exchange rate of trait  HR-Offshore 
  call self%mixing(self%dil_HO, var(1)%B_Pp*var(1)%l_Pp, self%relV_O,var(2)%B_Pp*var(2)%l_Pp, dTrait(1,1), dTrait(1,2))
!  dTrait(1,1) = dConci / var(1)%B_Pp
!  dTrait(1,2) = dConco / var(2)%B_Pp
  call self%mixing(self%dil_HO, var(1)%B_Be*var(1)%l_Be, self%relV_O,var(2)%B_Be*var(2)%l_Be, dTrait(2,1), dTrait(2,2))

 endif
 
! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb

! temperature dependency for egg spawning, somatic growth and mortalities 
  Temp_dep = f_temp(self%Q10, var(ib)%Temp, self%Tc)
  Temp_dep0= f_temp(self%Q10, var(ib)%Temp, 0.0d0)

! set coefficient vectors over ctenophore populations:  1: Beroe 2: Ppileus 
  lmsize(1) = var(ib)%l_Be  ! mean body size of population
  lmsize(2) = var(ib)%l_Pp  ! 
  dlopt(1)  = (self%loptA_Be-self%l0)/(self%lA-self%l0) ! increase in l_opt; feeding mode development
  dlopt(2)  = (self%loptA_Pp-self%l0)/(self%lA-self%l0)
  mass(1)   = var(ib)%B_Be  ! biomass concentration
  mass(2)   = var(ib)%B_Pp

  lco   = log(1E3/self%relCVDens)
  al0     = -9.95d0 

! set coefficient vectors over ctenophore populations:  1: Beroe 2: Ppileus 
!  loop over ctenophore populations:  1: Beroe 2: Ppileus 
  do i = 1, 2
    lopt(i) = self%l0 + (lmsize(i)-self%l0)*dlopt(i) ! optimal prey size

! potential maximum ingestion rate depending on size, T, and feeding mode
   ! re-gauge log size to µm-scale used in Wirtz JPR,2012     log(1E3/80)=2.5
   !    converts from log(µm) to log(mm) but accounts for much lower C-density  
   ! log(1E3/80) converts from log(micro-m) to log(mm) but accounts for much lower C-density
    al      = -0.4d0 * (lopt(i)-lmsize(i))
    Imax(i) = self%Imax_pot * exp( al + (2-al)*(lopt(i)+lco) +(al-3)*(lmsize(i)+lco) )

!    prod_lshift = sigma2(i) * Graz * (3*dl -1  + 3*dl/i13sig * dg_dB )
!    al1(i)  = 0.5*(1.0+Temp_dep)*(al-3 + dlopt(i)*(2-al))
    al1(i)  = Temp_dep*(al-3) +Temp_dep*dlopt(i)*(2-al)
!    al1(i)  = (al-Temp_dep*3 + dlopt(i)*(Temp_dep*2-al))
! correction to prevent unrealistic Imax-size dependency (see Fig.4 Wirtz JPR 2013)
 !   if (al1(i) .lt. al0) al1(i) = al0  

  ! global constants   TODO:put elsewhere
! std of size distribution increases at large mean size
    sig(i)  = self%sigma * ((self%lA-self%l0)*0.3333d0 + lmsize(i))
! TODO: refine empirical relationship using Greve or Finenko2003 data 
! sig(i) = self%sigma * (lmsize(i)*(2*self%lA-lmsize(i)))
    sigma2(i) = sig(i)*sig(i) ! variance from std
!  preyE = prey_eff(dl2, var(ib)%B_Be)
  end do
!  if (al1(1) .lt. -2.0d0) al1(1) = -2.0d0  
!  if (al1(2) .lt. -1.0d0) al1(2) = -1.d0  

 ! feeding of Ppileus on eggs/offspring
!  loop over ctenophore populations:  1: Beroe 2: Ppileus 
!  bcrit = self%Bcrit/self%relCVDens  ! critical feeding effort depends on prey C-biovolume-density
!  bcrit = self%Bcrit/self%relCVDens*10
  bcrit = self%Bcrit/10
  i13sig    = 1.0d0 + 3. * sigma2(2)   ! 
  do i = 1, 2
!    dlp(i)  = lmsize(i) -  lopt(2)                    ! size match to prey
!    dlp(i)  = self%l0 -  lopt(2)                    ! size match to prey
!    dl2     = 1.5d0*dlp(i)**2
    dl2     = 0.0d0
    f0(i)   = exp(-(lopt(2) -lmsize(i))**2/(2*sigma2(2)))
    preyE   = prey_eff(dl2,f0(i)*mass(i))
    mGPp(i) = Temp_dep*grazrate(dl2,Imax(2), bcrit, preyE)* mass(2)/(mass(i)+1E-3)
    dlp(i)  = (lmsize(i)- lopt(2))/i13sig * f0(i)*mGPp(i)           ! size match to prey

!   dg_dB = 1.0d0/(1.0d0/(bcrit*bcrit) + 1.0d0/(preyE*preyE)) 
  end do

  dg_dB = 0
  dl    = 0
! prep loop over ctenophore populations:  1: Beroe 2: Ppileus 
  do i = 1, 2

   dg_dB0 = dg_dB
   dl0    = dl  !var(ib)%l_Be  ! top-predator of Beroe on 1mm juvenile

   if (i .eq. 1) then
     lprey  = var(ib)%l_Pp ! Beroe only feeds on Pp 
     prey   = var(ib)%B_Pp
     mort_G = self%m_predBe * Temp_dep0 ! Beroe top-predator, if any
     al0    = -9.9d0
   else
     lprey  = -0.7d0      ! small copepods dominate. ! TODO: include as forcing
     prey   = var(ib)%Cop
     bcrit  = self%Bcrit
     mort_G = gross* var(ib)%B_Be / var(ib)%B_Pp ! mortality due to grazing
     al0    = -9.9d0
   endif
   if (al1(i) .lt. al0) al1(i) = al0  
   i13sig    = 1.0d0 + 3. * sigma2(i)   ! 

! how far way are juveniles from maturity? 
   argA  = (self%lA-lmsize(i))/(sqrt(2.d0)*sig(i))
!   if (argA .lt. -1.0) argA=-1.0d0 
   call self%errfunc(argA, errf, eargA)

! relative fraction of adhults 
   fA    = 0.5d0*(1.0d0 - errf) 

! size derivative of adult fraction
!   dfA_dl= sqrt(2.d0*3.1415)/sig(i) * eargA
! mean adult size
!   lm_adult = lmsize(i) + sigma2(i) * dfA_dl / fA
!   write (*,'(2(I3),2(F11.5))') ib,ic,lmsize(i)+lco,Imax

! secondary production by feeding on copepods/Ppileus 
   dl    = lprey -  lopt (i)                   ! size match to prey
   dl2   = 1.5d0*dl**2
   preyE = prey_eff(dl2, prey)  ! effective prey after integration over selection kernel
   gross = Temp_dep * grazrate(dl2, Imax(i), bcrit, preyE)

! physiological/starvation status affects yield (Reeve1986)
   mort_S0  = exp(-rg*gross)!
   yfac  = 1.0d0/(1.0d0+mort_S0)
   Graz  = self%yield * yfac * gross
   dg_dB = 1.0d0/(1.0d0/(bcrit*bcrit) + 1.0d0/(preyE*preyE)) 
! fraction of adult secondary production allocated to recruitment

   rS    = self%rgelC
!   rS    = 5.0-4.2*dlopt(i)
!   rg    = rS
!   rg    = 2.0d0 + 4*dlopt(i)
   lcrit = self%lA+1.0d0-2*Temp_dep
   eS    = exp(-(lcrit-lmsize(i))**2/i13sig) /sqrt(i13sig) 

!   fR    = fS * yfac
   fR    = yfac

!   fR    = 1.0d0/(1.0d0 + exp(2.+4*(self%lA-lm_adult)/sig(i)))
!   fR    = 0.5
! rate at which adults spawn new eggs
   recruit = fA * fR * Graz

   somgrwth= Graz - recruit

! physiological/starvation mortality 
!   mort_S  = self%mS * fA * exp(-1*Graz/Imax)
!   mort_S0  = self%mS * exp(-rS*gross/Imax)!
   mort_S0 = self%mS * mort_S0!

   mort_S  = mort_S0 * (1.0d0-eS)
  
! temperature dependent losses
   mort_R  = self%mR * Temp_dep0 ! *(1.0 + fS)

! offspring mortality and long-term consequences; TODO: include realisic lag
   fdejuv  = f0(i)*exp(2*(mGPp(i)-recruit)/self%mS)
   mort_J  = mGPp(i)*(f0(i) + fdejuv/(fdejuv+1.0d0) )

!  sum of all mortality rates
   mort_sum= mort_R + mort_S + mort_G + mort_J

   if (self%SizeDynOn) then
! egg production related part of size dynamics 
!   init_lshift = (self%l0 - lm_adult) * recruit
     init_lshift = (self%l0 - lmsize(i)) * recruit 
  
! somatic growth related part of size dynamics 
     som_lshift  = (Graz - recruit)/3

! marginal size shift due to selective grazing at neutral kernel width
!   shifts prey distribution away from l_opt_pred, thus to lower mortality
     dg_dlY      = -3*dl0/i13sig  * mort_G ! * dg_dB0
     dg_dlY2     = -3*dlp(i)    ! grazing pressure from offspring feeding of Pp
     graz_lshift = -sigma2(i) * (dg_dlY + 1*dg_dlY2) 

!  marginal size shift due to senescence
!    sen_lshift  = sigma2(i) * (0*mort_R + mort_Sself%mS * exp(-2*gross/Imax)* dfA_dl )
   if (self%OptionOn) then
!     sen_lshift  = sigma2(i) * rg*(rS-1.0d0)*fS*fS*eS*mort_S0
     sen_lshift  = sigma2(i) * mort_S0 * eS * 2* (lcrit-lmsize(i))/i13sig
   else
     sen_lshift  = 0.0d0
   endif

  ! resp_lshift   = - self%mR * Temp_dep0  *fS*fS*eS*rg

!  prod_lshift = 0.*sigma2(i) * Graz * (al-3 + dlopt(i)*(2-al + 3*dl/i13sig * dg_dB ))
    prod_lshift = sigma2(i) * Graz * (al1(i) + dlopt(i)* 3*dl/i13sig * dg_dB )

!  sum of all size selctive forces
    sum_lshift  = init_lshift + som_lshift + prod_lshift + graz_lshift + sen_lshift! + resp_lshift
   else
    sum_lshift  = 0.0d0
   endif

!#S__RHS
!#E__RHS
!---------- RHS for each state variable ----------
   if (i .eq. 1) then ! Beroe
! --- dynamics of Beroe biomass
    rhsv%B_Be = (Graz - mort_sum) * var(ib)%B_Be + self%immigr
! --- dynamics of Beroe mean log size
    rhsv%l_Be = sum_lshift

   ! Export diagnostic variables
    if (ib.eq.1) then
    _SET_DIAGNOSTIC_(self%id_prod_Be, Graz)        !step_integrated secondary production rate Beroe
    _SET_DIAGNOSTIC_(self%id_Mort_Be, mGPp(1))    !mort_sumstep_integrated mortality rate of Beroe
    _SET_DIAGNOSTIC_(self%id_fA_Be, mort_S0)            !step_integrated relative propotion adults Beroe
    _SET_DIAGNOSTIC_(self%id_Imax_Be, Imax(1))        !step_integrated maximum ingestion rate adult Beroe
    _SET_DIAGNOSTIC_(self%id_som_lshift, som_lshift)    !step_integrated marginal size shift due to promotion
    _SET_DIAGNOSTIC_(self%id_init_lshift, init_lshift)  !step_integrated marginal size shift due to egg production
    _SET_DIAGNOSTIC_(self%id_graz_lshift, graz_lshift)  !step_integrated marginal size shift due to selective grazing
    _SET_DIAGNOSTIC_(self%id_sen_lshift,sen_lshift)!step_integrated marginal size shift due to senescence 
    _SET_DIAGNOSTIC_(self%id_prod_lshift, prod_lshift)        !step_integrated marginal size shift due to production 

    endif

   else  !  P.Pileus
! --- dynamics of P.Pileus biomass
    rhsv%B_Pp = (Graz - mort_sum) * var(ib)%B_Pp + self%immigr
! --- dynamics of P.Pileus mean log size
    rhsv%l_Pp = sum_lshift

   ! Export diagnostic variables
    if (ib.eq.1) then

    _SET_DIAGNOSTIC_(self%id_prod_Pp, Graz)        !step_integrated secondary production rate P pileus
    _SET_DIAGNOSTIC_(self%id_Mort_Pp, mGPp(2))    !mort_sum step_integrated mortality rate of P pileus
    _SET_DIAGNOSTIC_(self%id_fA_Pp, mort_S0)            !step_integrated relative propotion adults P pileus
    _SET_DIAGNOSTIC_(self%id_Imax_Pp, Imax(2))        !step_integrated maximum ingestion rate adult Beroe
    _SET_DIAGNOSTIC_(self%id_somgrowth, somgrwth)  !step_integrated somatic growth rate 
    _SET_DIAGNOSTIC_(self%id_recruit, recruit)     !step_integrated egg production rate 
    _SET_DIAGNOSTIC_(self%id_mort_S, mort_S)       !step_integrated physiological adult mortality rate
    _SET_DIAGNOSTIC_(self%id_mort_R, mort_R)       !step_integrated dependent mortality
    _SET_DIAGNOSTIC_(self%id_mort_G, mort_G)       !step_integrated top-predation
    _SET_DIAGNOSTIC_(self%id_dl_prey, dl)                     !step_integrated size difference to prey 
    _SET_DIAGNOSTIC_(self%id_dl_pred, dl0)                    !step_integrated size difference to pred 
    _SET_DIAGNOSTIC_(self%id_al_Im, al1(2))         !al1(2) step_integrated size scaling expoentent Imax 
    _SET_DIAGNOSTIC_(self%id_mixBmass, dConc(2,1))            !step_integrated mass exchange rate Coast-HR-Offshore
    _SET_DIAGNOSTIC_(self%id_mixlsize, dTrait(2,1))           !step_integrated trait exchange rate Coast-HR-Offshore
    _SET_DIAGNOSTIC_(self%id_Tdep, Temp_dep)        !step_integrated Temperature dependence
    endif
  endif

!write (*,'(I3,2(F10.6))') ib,rhsv%AdPP,var(ib)%AdPP 
!#S__DIA
!#E__DIA
   end do
! ------------------------------------------------------------------------------
!#S_ODE
!---------- ODE for each state variable ----------
  _SET_ODE_(self%id_B_Pp(ib), rhsv%B_Pp UNIT)
  _SET_ODE_(self%id_l_Pp(ib), rhsv%l_Pp UNIT)
  _SET_ODE_(self%id_B_Be(ib), rhsv%B_Be UNIT)
  _SET_ODE_(self%id_l_Be(ib), rhsv%l_Be UNIT)
!#E_ODE
  end do

   ! Leave spatial loops (if any)
   _FABM_LOOP_END_

   end subroutine do
!EOC
! ------------------------------------------------------------------------------
  pure real(rk) function grazkinetics(bcrit,preye)
   implicit none
   real(rk), intent(in)      :: bcrit, preye
   real(rk)   :: hk
   hk  = 2.0d0
!   prey_eff     = prey/sqrt(i13sig) * exp(-dl2/i13sig)
   grazkinetics = preye**hk/(bcrit**hk + preye**hk)

   end function grazkinetics

! ------------------------------------------------------------------------------
! effective prey after integration over selection kernel  (Wirtz, MEPS 2014)
  pure real(rk) function prey_eff(dl2, prey)
   implicit none
   real(rk), intent(in)      :: dl2, prey
   prey_eff     = prey/sqrt(i13sig) * exp(-dl2/i13sig)
   end function prey_eff

! ------------------------------------------------------------------------------
  pure real(rk) function grazrate(dl2,Imax0, bcrit, prey)
   implicit none
   real(rk), intent(in)      :: dl2, Imax0, bcrit, prey
 !   real(rk)   :: dl2
   grazrate = Imax0  * exp(-dl2) * grazkinetics(bcrit,prey) 

   end function grazrate

! ------------------------------------------------------------------------------
  pure real(rk) function f_temp(q10,T,T_c)
   implicit none
   real(rk), intent(in)      :: q10,T,T_c
   real(rk)   :: q2
   q2      = q10**2
   f_temp  = 1.0d0/(q2 * exp(-T*q10/30)+ exp(-q2*(T-T_c)))

   end function f_temp

! ------------------------------------------------------------------------------
subroutine mixing(self,Dil,Conci,Volo,Conco, dConci, dConco)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: Dil,Conci,Volo,Conco
 real(rk), intent(inout)   :: dConci, dConco
 real(rk)   ::  Conc_mix
! mixing coefficients 
 Conc_mix = (Conco*Volo+Conci)/(Volo + 1.0d0)
 
 dConci = Dil* ( Conco - Conc_mix ) *  Volo
 dConco = Dil* ( Conci - Conc_mix ) 
end subroutine mixing

subroutine errfunc(self,arg,errf,ea2)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: arg
 real(rk), intent(inout)   :: errf, ea2
 real(rk)   :: art
  ea2 = exp(-arg*arg)
! error function approximation 
  art   = 1.0d0/(1.0d0+0.47047*arg)
  errf  = 1.0d0 - (0.3480242*art -0.0958798*art*art +0.7478556*art*art*art) * ea2
end subroutine errfunc

!EOC
end module fabm_hzg_jelly
#endif
