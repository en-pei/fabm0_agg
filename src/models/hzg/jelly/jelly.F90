#include "fabm_driver.h"
!#ifdef _FABM_F2003_
! --------------------------------------------
! Size- & distribution based ctenophore model
! kai wirtz Apr 2014
! --------------------------------------------
module fabm_hzg_jelly
!
! !USES:
  use fabm_types
  use fabm_driver
  implicit none

 !public flags for communication with fabm-driver/time-loop
  !character(len=80),   public      ::  jelly_timestr
  !integer,             public      ::  OutJellyRGR, CalcJellyRGR
  public grazkinetics

  private
 ! HZG model types
  !type type_diff
  ! real(rk) :: mu, dmudl, d2mudl2, dmudV, dsinkdl, dsinkdp, d2mudl2_d, dmu_d
  !end type
  integer   :: numb=1
  real(rk)  :: i13sig

!#SP0
!!----------------------------------------------------------------------
!! this code is generated by a parser  (conv_nml_fabm.c by kai wirtz)
!!----------------------------------------------------------------------
! --- HZG model types
type type_jelly_var
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be,B_Det,Parasite
 real(rk) :: Cop,Temp,Wind
end type
type type_jelly_rhs
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be,B_Det,Parasite
end type
! standard fabm model types
type,extends(type_base_model),public :: type_hzg_jelly
type (type_state_variable_id)        :: id_B_Pp,id_l_Pp,id_B_Be,id_l_Be,id_B_Det,id_Parasite
type (type_dependency_id)            :: id_Cop
type (type_dependency_id)            :: id_Temp
type (type_dependency_id)            :: id_Wind
type (type_diagnostic_variable_id)   :: id_prod_Be, id_Mort_Be, id_fA_Be, id_Imax_Be, id_lopt_Be, id_prod_Pp, id_Mort_Pp, id_fA_Pp, id_Imax_Pp, id_mort_P, id_mort_S, id_mort_R, id_mort_G, id_mort_J, id_mort_T, id_somgrowth, id_recruit, id_paras_dl, id_som_dl, id_turb_dl, id_init_dl, id_graz_dl, id_sen_dl, id_prod_dl, id_resp_dl, id_dl_prey, id_dl_pred, id_al_Im, id_mixBmass, id_mixlsize, id_Tdep
real(rk) ::  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial, B_Det_initial, Parasite_initial
real(rk) ::  lA, l0, lstarv, sigma, Imax_pot, yield, mR, mS, mP, mT, Q10, Tc, Bcrit, relCVDens, m_predBe, loptA_Pp, loptA_Be, immigr, rDet, rParasite, W_turb_exp, mDisturb
logical  ::  TransectOn, SizeDynOn, LowPassOn, OptionOn, MortSizeOn

contains
!   Model procedures
procedure :: initialize
procedure :: do
end type type_hzg_jelly

!
! !PRIVATE DATA MEMBERS:
 real(rk), parameter :: secs_pr_day = 86400.0_rk
!EOP
!!--------------------------------------------------------------------

contains
!> @brief initializes the model
!! @details here the maecs namelists are read and assigned respectively in the model type (self),
!! state & diagnostic variables are registered in FABM and dependencies are imported from FABM
!>
!> **Model parameters, descriptions and corresponding symbols used in formulas:**
! initial values
!> \describepar{TransectOn   ,    , mixing between coastal transect boxes, .false. }
!> \describepar{SizeDynOn    ,     , life stage cycling enabled, .true. }
!> \describepar{LowPassOn    ,     , filter high frequency in forcing, .true. }
!> \describepar{OptionOn     ,      , generic, .false. }
!> \describepar{MortSizeOn   ,    , size dependency in mortality,  }
! other parameters
!> \describepar{lA           , \ell_A           , adult ctenophore size        , 1.8 log(ESD/mm)}
!> \describepar{l0           , \ell_0           , offspring size, -1.2 log(ESD/mm)}
!> \describepar{lstarv       , \ell_S       , minimum starvation size, 1.8 log(ESD/mm)}
!> \describepar{sigma        , \sigma'        , log-size specific std deviation , 1. log(ESD/mm)^2}
!> \describepar{Imax_pot     , I_\mathrm{max}^*     , maximum ingestion rate for ideal consumer, prey, T, and food , 173. 1/d}
!> \describepar{yield        , y_0        , assimilation efficiency, 0.65 }
!> \describepar{mR           , m_R^0           , temperature dependent, natural mortality rate , 0.2 1/d}
!> \describepar{mS           , m_S^0           , physiological mortality under senescence , 0.2 1/d}
!> \describepar{mP           , m_P^0           , density dependent mortality rate (parasites), 5e-06 1/d.µg-C/L}
!> \describepar{mT           , m_{T}^0           , mortality due to physical damage (turbulence) 0.028, 0. 1/d}
!> \describepar{Q10          , Q_{10}          , rate increase at 10C temperature rise, 2.2 }
!> \describepar{Tc           , ^o$C] $T_c           , critical threshold temperature, 4.5 $^o$C}
!> \describepar{Bcrit        , B^*        , minimal prey biomass (Holling-III) , 10.0 µg-C/L}
!> \describepar{relCVDens    , R_\rho    , C-biovolume density ratio non-gelatinous/gelatinous plankton, 80.0 µg-C/L}
!> \describepar{m_predBe     , m_\mathrm{top}     , loss rate of Beroe due to top-predator , 0.0 1/d}
!> \describepar{loptA_Pp     , \lcsize_\mathrm{opt,Pp}^A     , optimal prey size adult P.pileus , -0.60 }
!> \describepar{loptA_Be     , \lcsize_\mathrm{opt,Be}^A     , optimal prey size adult Beroe , 1.4 }
!> \describepar{immigr       , \epsilon_\mathrm{in}       , migration mass inflow rate , 3e-05 µg-C/L.d}
!> \describepar{rDet         , r_\mathrm{Det}         , detritus turnover rate , 0.035 1/d}
!> \describepar{rParasite    , r_\mathrm{P}    , low size of cop parasitism rel to cten size, 0.1 }
!> \describepar{W_turb_exp   , w_\mathrm{turb}   , exponent of wind-turbulence relation  , 1.0 }
!> \describepar{mDisturb     , B_\mathrm{cd}     , critical mass concentration detection disturbance   , 7.0 µg-C/L}
subroutine initialize(self, configunit)

class (type_hzg_jelly), intent(inout), target :: self
integer,                  intent(in)            :: configunit
!
! !LOCAL VARIABLES:
integer    :: namlst=19
!!------- Initial values of model jelly ------- 
!> \describepar{B_Pp_initial , B_\mathrm{Pp} , P.Pileus biomass, 3E-2 µg-C/L}
!> \describepar{l_Pp_initial , \ell_\mathrm{Pp} , P.Pileus mean log size, 1.4 log(ESD/mm)}
!> \describepar{B_Be_initial , B_\mathrm{Be} , Beroe biomass, 1E-4 µg-C/L}
!> \describepar{l_Be_initial , \ell_\mathrm{Be} , Beroe mean log size, 1.25 log(ESD/mm)}
!> \describepar{B_Det_initial , \ell_\mathrm{Be} , detritus, 50. µg-C/L}
!> \describepar{Parasite_initial , \ell_\mathrm{Be} , parasite, 50. µg-C/L}
real(rk)  :: B_Pp_initial ! P.Pileus biomass
real(rk)  :: l_Pp_initial ! P.Pileus mean log size
real(rk)  :: B_Be_initial ! Beroe biomass
real(rk)  :: l_Be_initial ! Beroe mean log size
real(rk)  :: B_Det_initial ! detritus
real(rk)  :: Parasite_initial ! parasite
!> describepar{lA           , \ell_A           , adult ctenophore size        , 1.8 log(ESD/mm)}
!> describepar{l0           , \ell_0           , offspring size, -1.2 log(ESD/mm)}
!> describepar{lstarv       , \ell_S       , minimum starvation size, 1.8 log(ESD/mm)}
!> describepar{sigma        , \sigma'        , log-size specific std deviation , 1. log(ESD/mm)^2}
!> describepar{Imax_pot     , I_\mathrm{max}^*     , maximum ingestion rate for ideal consumer, prey, T, and food , 173. 1/d}
!> describepar{yield        , y_0        , assimilation efficiency, 0.65 }
!> describepar{mR           , m_R^0           , temperature dependent, natural mortality rate , 0.2 1/d}
!> describepar{mS           , m_S^0           , physiological mortality under senescence , 0.2 1/d}
!> describepar{mP           , m_P^0           , density dependent mortality rate (parasites), 5e-06 1/d.µg-C/L}
!> describepar{mT           , m_{T}^0           , mortality due to physical damage (turbulence) 0.028, 0. 1/d}
!> describepar{Q10          , Q_{10}          , rate increase at 10C temperature rise, 2.2 }
!> describepar{Tc           , ^o$C] $T_c           , critical threshold temperature, 4.5 $^o$C}
!> describepar{Bcrit        , B^*        , minimal prey biomass (Holling-III) , 10.0 µg-C/L}
!> describepar{relCVDens    , R_\rho    , C-biovolume density ratio non-gelatinous/gelatinous plankton, 80.0 µg-C/L}
!> describepar{m_predBe     , m_\mathrm{top}     , loss rate of Beroe due to top-predator , 0.0 1/d}
!> describepar{loptA_Pp     , \lcsize_\mathrm{opt,Pp}^A     , optimal prey size adult P.pileus , -0.60 }
!> describepar{loptA_Be     , \lcsize_\mathrm{opt,Be}^A     , optimal prey size adult Beroe , 1.4 }
!> describepar{immigr       , \epsilon_\mathrm{in}       , migration mass inflow rate , 3e-05 µg-C/L.d}
!> describepar{rDet         , r_\mathrm{Det}         , detritus turnover rate , 0.035 1/d}
!> describepar{rParasite    , r_\mathrm{P}    , low size of cop parasitism rel to cten size, 0.1 }
!> describepar{W_turb_exp   , w_\mathrm{turb}   , exponent of wind-turbulence relation  , 1.0 }
!> describepar{mDisturb     , B_\mathrm{cd}     , critical mass concentration detection disturbance   , 7.0 µg-C/L}
!!------- Parameters from nml-list jelly_pars ------- 
real(rk)  :: lA           ! adult ctenophore size        
real(rk)  :: l0           ! offspring size
real(rk)  :: lstarv       ! minimum starvation size
real(rk)  :: sigma        ! log-size specific std deviation 
real(rk)  :: Imax_pot     ! maximum ingestion rate for ideal consumer, prey, T, and food 
real(rk)  :: yield        ! assimilation efficiency
real(rk)  :: mR           ! temperature dependent, natural mortality rate 
real(rk)  :: mS           ! physiological mortality under senescence 
real(rk)  :: mP           ! density dependent mortality rate (parasites)
real(rk)  :: mT           ! mortality due to physical damage (turbulence) 0.028
real(rk)  :: Q10          ! rate increase at 10C temperature rise
real(rk)  :: Tc           ! critical threshold temperature
real(rk)  :: Bcrit        ! minimal prey biomass (Holling-III) 
real(rk)  :: relCVDens    ! C-biovolume density ratio non-gelatinous/gelatinous plankton
real(rk)  :: m_predBe     ! loss rate of Beroe due to top-predator 
real(rk)  :: loptA_Pp     ! optimal prey size adult P.pileus 
real(rk)  :: loptA_Be     ! optimal prey size adult Beroe 
real(rk)  :: immigr       ! migration mass inflow rate 
real(rk)  :: rDet         ! detritus turnover rate 
real(rk)  :: rParasite    ! low size of cop parasitism rel to cten size
real(rk)  :: W_turb_exp   ! exponent of wind-turbulence relation  
real(rk)  :: mDisturb     ! critical mass concentration detection disturbance   
!!------- Switches for configuring model structure -------
logical   :: TransectOn   ! mixing between coastal transect boxes
logical   :: SizeDynOn    ! life stage cycling enabled
logical   :: LowPassOn    ! filter high frequency in forcing
logical   :: OptionOn     ! generic
logical   :: MortSizeOn   ! size dependency in mortality

namelist /jelly_init/ &
  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial, B_Det_initial, &
  Parasite_initial

namelist /jelly_pars/ &
  lA, l0, lstarv, sigma, Imax_pot, yield, mR, mS, mP, mT, Q10, Tc, Bcrit, relCVDens, m_predBe, &
  loptA_Pp, loptA_Be, immigr, rDet, rParasite, W_turb_exp, mDisturb

namelist /jelly_switch/ &
  TransectOn, SizeDynOn, LowPassOn, OptionOn, MortSizeOn

B_Pp_initial = 3E-2_rk            ! µg-C/L
l_Pp_initial = 1.4_rk             ! log(ESD/mm)
B_Be_initial = 1E-4_rk            ! µg-C/L
l_Be_initial = 1.25_rk            ! log(ESD/mm)
B_Det_initial = 50._rk             ! µg-C/L
Parasite_initial = 50._rk             ! µg-C/L
lA           = 1.8_rk             ! log(ESD/mm)
l0           = -1.2_rk            ! log(ESD/mm)
lstarv       = 1.8_rk             ! log(ESD/mm)
sigma        = 1._rk              ! log(ESD/mm)^2
Imax_pot     = 173._rk            ! 1/d
yield        = 0.65_rk            ! 
mR           = 0.2_rk             ! 1/d
mS           = 0.2_rk             ! 1/d
mP           = 5e-06_rk           ! 1/d.µg-C/L
mT           = 0._rk              ! 1/d
Q10          = 2.2_rk             ! 
Tc           = 4.5_rk             ! $^o$C
Bcrit        = 10.0_rk            ! µg-C/L
relCVDens    = 80.0_rk            ! µg-C/L
m_predBe     = 0.0_rk             ! 1/d
loptA_Pp     = -0.60_rk           ! 
loptA_Be     = 1.4_rk             ! 
immigr       = 3e-05_rk           ! µg-C/L.d
rDet         = 0.035_rk           ! 1/d
rParasite    = 0.1_rk             ! 
W_turb_exp   = 1.0_rk             ! 
mDisturb     = 7.0_rk             ! µg-C/L


!--------- read namelists --------- 
write(0,*) ' read namelists ....'
open(namlst,file='jelly_init.nml',status='old')
read(namlst,nml=jelly_init,err=90,end=99)
open(namlst,file='jelly_pars.nml',status='old')
read(namlst,nml=jelly_pars,err=91,end=100)
open(namlst,file='jelly_switch.nml',status='old')
read(namlst,nml=jelly_switch,err=92,end=101)
! Store parameter values in our own derived type
! NB: all rates must be provided in values per day,
! and are converted here to values per second.

!!------- logical parameters: switches  -------
call self%get_parameter(self%TransectOn,    'TransectOn',    default=TransectOn)
call self%get_parameter(self%SizeDynOn,     'SizeDynOn',     default=SizeDynOn)
call self%get_parameter(self%LowPassOn,     'LowPassOn',     default=LowPassOn)
call self%get_parameter(self%OptionOn,      'OptionOn',      default=OptionOn)
call self%get_parameter(self%MortSizeOn,    'MortSizeOn',    default=MortSizeOn)

!!------- model parameters from nml-list jelly_init ------- 
call self%get_parameter(self%B_Pp_initial ,'B_Pp_initial',  default=B_Pp_initial)
call self%get_parameter(self%l_Pp_initial ,'l_Pp_initial',  default=l_Pp_initial)
call self%get_parameter(self%B_Be_initial ,'B_Be_initial',  default=B_Be_initial)
call self%get_parameter(self%l_Be_initial ,'l_Be_initial',  default=l_Be_initial)
call self%get_parameter(self%B_Det_initial ,'B_Det_initial',  default=B_Det_initial)
call self%get_parameter(self%Parasite_initial ,'Parasite_initial',  default=Parasite_initial)

!!------- model parameters from nml-list jelly_pars ------- 
call self%get_parameter(self%lA           ,'lA',            default=lA)
call self%get_parameter(self%l0           ,'l0',            default=l0)
call self%get_parameter(self%lstarv       ,'lstarv',        default=lstarv)
call self%get_parameter(self%sigma        ,'sigma',         default=sigma)
call self%get_parameter(self%Imax_pot     ,'Imax_pot',      default=Imax_pot)
call self%get_parameter(self%yield        ,'yield',         default=yield)
call self%get_parameter(self%mR           ,'mR',            default=mR)
call self%get_parameter(self%mS           ,'mS',            default=mS)
call self%get_parameter(self%mP           ,'mP',            default=mP)
call self%get_parameter(self%mT           ,'mT',            default=mT)
call self%get_parameter(self%Q10          ,'Q10',           default=Q10)
call self%get_parameter(self%Tc           ,'Tc',            default=Tc)
call self%get_parameter(self%Bcrit        ,'Bcrit',         default=Bcrit)
call self%get_parameter(self%relCVDens    ,'relCVDens',     default=relCVDens)
call self%get_parameter(self%m_predBe     ,'m_predBe',      default=m_predBe)
call self%get_parameter(self%loptA_Pp     ,'loptA_Pp',      default=loptA_Pp)
call self%get_parameter(self%loptA_Be     ,'loptA_Be',      default=loptA_Be)
call self%get_parameter(self%immigr       ,'immigr',        default=immigr)
call self%get_parameter(self%rDet         ,'rDet',          default=rDet)
call self%get_parameter(self%rParasite    ,'rParasite',     default=rParasite)
call self%get_parameter(self%W_turb_exp   ,'W_turb_exp',    default=W_turb_exp)
call self%get_parameter(self%mDisturb     ,'mDisturb',      default=mDisturb)

!!------- Register state variables  ------- 
call self%register_state_variable(self%id_B_Pp,  'B_Pp','µg-C/L','P.Pileus biomass B_Pp', &
   B_Pp_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_l_Pp,  'l_Pp','log(ESD/mm)','P.Pileus mean log size l_Pp', &
   l_Pp_initial, minimum=-3.0d0, no_river_dilution=.true. )
call self%register_state_variable(self%id_B_Be,  'B_Be','µg-C/L','Beroe biomass B_Be', &
   B_Be_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_l_Be,  'l_Be','log(ESD/mm)','Beroe mean log size l_Be', &
   l_Be_initial, minimum=-3.0d0, no_river_dilution=.true. )
call self%register_state_variable(self%id_B_Det, 'B_Det','µg-C/L','detritus B_Det', &
   B_Det_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_Parasite, 'Parasite','µg-C/L','parasite Parasite', &
   Parasite_initial, minimum=_ZERO_, no_river_dilution=.true. )

!!------- Register diagnostic variables  ------- 
call self%register_diagnostic_variable(self%id_prod_Be, 'prod_Be','1/d', 'secondary production rate Beroe prod_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Be, 'Mort_Be','1/d', 'mortality rate of Beroe Mort_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Be,   'fA_Be','1/d', 'relative propotion adults Beroe fA_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Be, 'Imax_Be','1/d', 'maximum ingestion rate adult Beroe Imax_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_lopt_Be, 'lopt_Be','1/d', 'optimum prey size Beroe lopt_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_Pp, 'prod_Pp','1/d', 'secondary production rate P pileus prod_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Pp, 'Mort_Pp','1/d', 'mortality rate of P pileus Mort_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Pp,   'fA_Pp','1/d', 'relative propotion adults P pileus fA_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Pp, 'Imax_Pp','1/d', 'maximum ingestion rate adult Beroe Imax_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_P,  'mort_P','1/d', 'density dependent mortality - parasites mort_P', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_S,  'mort_S','1/d', 'physiological adult mortality rate mort_S', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_R,  'mort_R','1/d', 'temperature dependent mortality mort_R', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_G,  'mort_G','1/d', 'top-predation mort_G', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_J,  'mort_J','1/d', 'juvenile mortality mort_J', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_T,  'mort_T','1/d', 'damaging effect of turbulence mort_T', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_somgrowth, 'somgrowth','1/d', 'somatic growth rate  somgrowth', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_recruit, 'recruit','1/d', 'egg production rate  recruit', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_paras_dl, 'paras_dl','1/d', 'marginal size shift parasites paras_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_som_dl,  'som_dl','1/d', 'marginal size shift due to promotion som_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_turb_dl, 'turb_dl','1/d', 'marginal size shift due to physical damage turb_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_init_dl, 'init_dl','1/d', 'marginal size shift due to egg production init_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_graz_dl, 'graz_dl','1/d', 'marginal size shift due to selective grazing graz_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_sen_dl,  'sen_dl','1/d', 'marginal size shift due to starvation  sen_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_dl, 'prod_dl','1/d', 'marginal size shift due to production  prod_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_resp_dl, 'resp_dl','1/d', 'marginal size shift due to respiration  resp_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_prey, 'dl_prey','1/d', 'size difference to prey  dl_prey', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_pred, 'dl_pred','1/d', 'size difference to pred  dl_pred', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_al_Im,   'al_Im','1/d', 'size scaling expoentent Imax  al_Im', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixBmass, 'mixBmass','1/d', 'mass exchange rate Coast-HR-Offshore mixBmass', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixlsize, 'mixlsize','1/d', 'trait exchange rate Coast-HR-Offshore mixlsize', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Tdep,    'Tdep','1/d', 'Temperature dependence Tdep', &
  output=output_instantaneous)

!!------- Register environmental dependencies  ------- 
call self%register_dependency(self%id_Cop,standard_variables%downwelling_photosynthetic_radiative_flux)
call self%register_dependency(self%id_Temp,standard_variables%temperature)
call self%register_dependency(self%id_Wind,standard_variables%practical_salinity)

! extra line included from parser var init_incl 
#define UNIT *1.1574074074E-5_rk

return

!!-------  if files are not found ...  
90 call self%fatal_error('jelly_init','Error reading namelist jelly_init.')
91 call self%fatal_error('jelly_init','Error reading namelist jelly_pars.')
92 call self%fatal_error('jelly_init','Error reading namelist jelly_switch.')
99 call self%fatal_error('jelly_init','Namelist jelly_init was not found in file.')
100 call self%fatal_error('jelly_init','Namelist jelly_pars was not found in file.')
101 call self%fatal_error('jelly_init','Namelist jelly_switch was not found in file.')

end subroutine initialize

!!----------------------------------------------------------------------
!!   end of section generated by parser 
!!----------------------------------------------------------------------
! #SP#"
!
!INTERFACE:
  subroutine do(self,_ARGUMENTS_DO_)
!
! !INPUT PARAMETERS:
  class (type_hzg_jelly),intent(in) :: self
  _DECLARE_ARGUMENTS_DO_
!
!LOCAL VARIABLES:

  type (type_jelly_var), dimension(3)       :: var
  type (type_jelly_rhs)       :: rhsv
  !type (type_diff)      :: diff,diff2
  !real(rk)              :: d2mudl2_d, dmu2=0.0_rk, mfac
!  type (type_environment),   intent(inout)  :: environment 
  real(rk) :: mort_S, mort_S0,mort_SJ, mort_R, mort_R0, mort_T0, mort_G
  real(rk) :: mort_J, mort_AJ, mort_P, mort_T, mort_sum, mass_sum
  real(rk) :: errf, eargA, argA, aa, rS, pS, eS, eS0, al0,alr, yfac
  real(rk) :: Imaxr, lesdr, efn, efp, dll,loptm, m_host, sBDet,detect
  real(rk) :: somgrwth, recruit,lco, mGBe, f_tc, starv, dal_dl, min_dl, bound_dl
  real(rk) :: prod_dl, sum_dl, resp_dl,paras_dl, turb_dl
  real(rk) :: graz_dl, som_dl, init_dl, sen_dl
  real(rk), dimension(2,numb) :: dConc,dTrait
  real(rk), dimension(3) :: Imax, al1, dlopt,lopt, graz,Temp_dep, Temp_dep0, preyc, dg_dl
  real(rk), dimension(3) :: mGrz, mGrz0, sig, sigma2, lmsize, dlp,dlpp, mass, relDens,loptA
  real(rk) :: dl0, dl, dl2, bcrit, prey, preyE, preyT, mGP, fLc, aS=2.0
  real(rk) :: fR, fA, dfA_dl, lm_adult, al, lprey, lcrit, lavg
  real(rk) :: gross, Prod, dg_dB, dB_dl, dg_dlY, srS, mS0, mT0, ratf
  integer  :: ib, ic, i, j
!  real(rk) :: inflow=2E-1, Adorm=2E-3

! !REVISION HISTORY:
!  Original author(s): Kai Wirtz

! !DESCRIPTION:
! Stage-based Pleurobrachia & Beroe   Model
!
!EOP
!-----------------------------------------------------------------------
!BOC
! argA  = 0.5*(self%lA+self%l0)/(sqrt(2.d0)*self%sigma)
! relative fraction of adhults 
! fA0    = 0.5d0*(1.0d0 - errf) 
! unify all mortalities
if(self%mS .lt. -0.001d0) then
   mS0 = self%mR
else
   mS0 = self%mS
endif
if(self%mT .lt. -0.001d0) then
   mT0 = self%mR
else
   mT0 = self%mT
endif


! ! self%mAJ = self%mR

   ! Enter spatial loops (if any)
_FABM_LOOP_BEGIN_

! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb

!#S_GET
!---------- GET for each state variable ----------
  _GET_(self%id_B_Pp, var(ib)%B_Pp)  ! P.Pileus biomass in µg-C/L
  _GET_(self%id_l_Pp, var(ib)%l_Pp)  ! P.Pileus mean log size in log(ESD/mm)
  _GET_(self%id_B_Be, var(ib)%B_Be)  ! Beroe biomass in µg-C/L
  _GET_(self%id_l_Be, var(ib)%l_Be)  ! Beroe mean log size in log(ESD/mm)
  _GET_(self%id_B_Det, var(ib)%B_Det)  ! detritus in µg-C/L
  _GET_(self%id_Parasite, var(ib)%Parasite)  ! parasite in µg-C/L
!#E_GET
   ! Retrieve current environmental conditions.
!#S_GED
  _GET_(self%id_Cop, var(ib)%Cop)  ! biomass from Greve data-set
  _GET_(self%id_Temp, var(ib)%Temp)  ! temperature HR
  _GET_(self%id_Wind, var(ib)%Wind)  ! wind  HR
!#E_GED

 end do
!
! ---------- set environmental conditions for each box  -------------------
!
!write (*,'(A,3(F10.3))') 'temp=',var(1)%Temp,var(2)%Temp,var(3)%Temp
! ib=1 HR   2: Coast  3:Offshore
! open water: less copepods, and reduced temperature fluctuation
!  var(2)%Cop  = 1.5 * var(2)%Cop
!  var(2)%Temp = -0.5 + 1.15*var(2)%Temp

! f_tc  = 1.0d0/(exp(-(self%TempC_0-20.0d0)*0.1*log(self%Q10)) + 0.0d0)

! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb
!
! ---------- set specific variables for each population  -------------------
!
! set coefficient vectors over prey populations:  1: Beroe 2: Ppileus  3: Cops
  lmsize(1) = var(ib)%l_Be  ! mean body size of population
  lmsize(2) = var(ib)%l_Pp  ! 
  lmsize(3) = -0.7d0        ! small copepods dominate. ! TODO: include as forcing 
  sigma2(3) = 0.8d0         ! log-size variance of mesozooplakton
  mass(1)   = var(ib)%B_Be  ! biomass concentration
  mass(2)   = var(ib)%B_Pp
  mass(3)   = var(ib)%Cop 

  relDens(3)= 1.0d0         ! rel. C-biovolume density ratio of non-gelatinous plankton
  dlopt(1)  = (self%loptA_Be-self%l0)/(self%lA-self%l0) ! increase in l_opt; feeding mode development
  dlopt(2)  = (self%loptA_Pp-self%l0)/(self%lA-self%l0)
!  lopt(3)  = (-2.0-self%l0)/(self%lA-self%l0)
  lopt(3)   = -3.0d0
!  loptm(3)  = lopt(3)

  Imax(3)   = 1.0d0
  Temp_dep(3) = f_temp(2.5d0, var(ib)%Temp, 0.0d0)

! re-gauge coefficient to apply  Imax-scaling of Wirtz JPR,2012 
!    log(1E3/80) converts from log(micro-m) to log(mm) but accounts for much lower C-density
! optimum size/stage with minimal life-stage dependent mortality 
  lavg    = 0.5*(self%lA + self%l0) ! 0.4
!  loop over ctenophore populations:  1: Beroe 2: Ppileus 

  do i = 1, 2
    relDens(i)= self%relCVDens
    lco       = log(1E3/self%relCVDens)
    lopt(i)   = self%l0 + (lmsize(i)-self%l0)*dlopt(i) ! optimal prey size
    loptA(i)   = self%l0 + (self%lA-self%l0)*dlopt(i) ! optimal prey size
! potential maximum ingestion rate depending on size, T, and feeding mode
   ! re-gauge log size to µm-scale used in Wirtz JPR,2012     log(1E3/80)=2.5
   !    converts from log(µm) to log(mm) but accounts for much lower C-density  
!    lesdr     = 0.0d0
    dal_dl    = 0.41d0 * (1.0 - dlopt(i))
    if (.true.) then
! correction to prevent unrealistic Imax-size dependency for juveniles (see Fig.4 Wirtz JPR 2013)
      argA      = lmsize(i)/lavg
      efp       = exp(argA)
      efn       = exp(-argA)
      lesdr   = (lmsize(i)*efp + lavg)/(efp+efn)
      loptm   = self%l0 + (lesdr-self%l0)*dlopt(i) ! optimal prey size
    else
      lesdr   = lmsize(i)
      loptm   = lopt(i) ! optimal prey size
    endif

    al      = -0.41d0 * (loptm-lesdr)
    Imax(i) = self%Imax_pot * exp( al + (2-al)*(loptm+lco) +(al-3)*(lesdr+lco) )

!    al1(i)  = Temp_dep*(al-3) +Temp_dep*dlopt(i)*(2-al)
! size derivative of Imax-scaling
!    al1(i)    = (al-3) + dlopt(i)*(2-al)
    al1(i)  = (al-3) + dlopt(i)*(2-al) + dal_dl*(1.0d0 - loptm + lesdr)

    if (.true.) then
      dll     = ( (1.0d0+argA)*(efp*efp+1.0d0) - (efp+efn)*(argA*efp+1.0d0))/(efp+efn)**2
      al1(i)  = al1(i)* dll
    endif

!    al0       = -2.5d0
!    if (al1(i) .lt. al0) al1(i) = al0  

! temperature dependency for egg spawning, somatic growth and mortalities 
  if (self%OptionOn) then
    Temp_dep(i) = f_temp(self%Q10 +1*lopt(i), var(ib)%Temp, self%Tc)
  else
    Temp_dep(i) = f_temp(self%Q10 +0*lopt(i), var(ib)%Temp, self%Tc)
  endif
!  Temp_dep0= f_temp(self%Q10, var(ib)%Temp, 0.0d0)

! std of size distribution increases at large mean size and drops at very low number concentration
!    rS        = self%lA + (1.0d0-self%lA)*sqrt(mass(i))/(sqrt(mass(i))+sqrt(self%sigmbc))
! TODO: refine empirical relationship using Falkenhaug1996 or Finenko2003 data 

!  lopt = l0 + (ml*0-l0)*dlopt(sp) % optimal prey size
!  mstd=sqrt(dl.*exp(-((ml-lmsize)./(sqrt(2)*dl)).^2));
!    lcrit     = self%l0 + (0-self%lA*self%l0)*dlopt(i)
    lcrit     = self%l0 * (1.0d0 - 0.*dlopt(i))
!    lcrit     = self%l0
    dl        = (self%lA +lcrit - 2*self%l0)/4
!    if (i .eq. -1) then      dl=dl*1.     endif
!    dl        = (self%lA - self%l0)/3.1415  dl=(lAv(sp)+lopt-2*l0)/4; 
!  lopt = l0 + (ml*0-l0)*dlopt(sp) % optimal prey size
!  mstd=sqrt(dl.*exp(-((ml-lmsize)./(sqrt(2)*dl)).^2));
!    sigma2(i) = self%sigma * dl * exp(-((lavg-lmsize(i))/(sqrt(2.0d0)*dl))**2)
    sigma2(i) = self%sigma * exp(-0.5*(lavg-lmsize(i))**2)
    sig(i)    = sqrt(sigma2(i))

! set accumulating stores to zero
!    graz(i)   = 0.0d0
!    dlpp(i)   = 0.0d0
  end do
!  mass_sum  = 0.0d0
  mass_sum  = 0.*var(ib)%B_Det
  do j = 1, 3
    dlp(j)    = 0.0d0
    mGrz(j)   = 0.0d0
!    mGrz0(j)  = 0.0d0
    mass_sum  = mass_sum + mass(i)
  end do
!
! ---------- calculate RHS  -------------------
!
! ----------  loop over all trophic interactions  -------------------
!
!  loop over (ctenophore) predators
  do i = 1, 2
!  loop over prey populations:  1: Beroe 2: Ppileus 3: Cops
   dB_dl   = 0.0d0
   preyT   = 0.0d0
   do j = 1, 1+i  ! calc total available prey biomass first
     i13sig  = 1.0d0/(1.0d0 + 3*sigma2(j))     ! 
     dl      = lmsize(j) - lopt(i)     ! size match to prey
     dl2     = 1.5d0*dl**2             ! feeding kernel argument, assumes "neutral" selectivity s=3/2
     preyc(j)= prey_effc(dl2)  ! effective prey mass after integration over selection kernel
!     preyE   = prey_eff(dl2,mass(j) )  
!     if (i.eq.1 .and. j.eq.1 ) preyc(j)= preyc(j)*  exp(1*(self%l0-lopt(i))/sig(i)) ! reduce cannibalism in Beroe (Hosia2011)     
!     if (i.eq.1 .and. j.eq.1 ) preyc(j)= preyc(j)* 0. ! reduce cannibalism in Beroe (Hosia2011)     
     preyE   = preyc(j)* mass(j) ! effective prey mass after integration over selection kernel
     preyT   = preyT + preyE  ! effective prey mass after integration over selection kernel
     dB_dl   = dB_dl + preyE * dlopt(i)* 3*dl*i13sig   ! derivative of prey-mass with respect to consumer size (through optimal prey size dependency)
   end do

! effect of reduces prey detectability at high consumer density
!   detect  = 2.0d0/(1.0d0+exp(mass(i)/self%T_turb))
!   detect  = 1.0d0 - exp(-self%mDisturb/(mass(i)*exp(lmsize(i)-lopt(i)-1.0d0))**2+1E-5)
   detect  = (mass(1)+mass(2))/self%mDisturb !*exp(lmsize(i)-lopt(i))
!   detect  = 2.0d0/(1.0d0+exp(detect))
   detect  = exp(-detect**2)
   bcrit   = self%Bcrit/relDens(i+1) ! half-sturation constant TODDO: replace with mechanistic par
   bcrit   = bcrit * exp((al1(i)-0.5d0)*lmsize(j))  ! constant affinity induces scaling in half-saturation constant
   gross   = detect*Temp_dep(i) * grazrate(dl2, Imax(i), bcrit, preyT) ! grazing rate

  ! update all flux stores
!   graz(i) = graz(i) + gross
   graz(i) = gross  
   ratf    = preyT/bcrit
   argA    = Temp_dep(i)*Imax(i)* exp(-ratf) * detect
   dlpp(i) = dB_dl * argA /bcrit
   dg_dl(i)= -(al1(i)-0.5d0)*ratf * argA  ! derivative through half-saturation

   do j = 1, 1+i  ! calc total available prey biomass first

     mGP     = gross* preyc(j)*mass(i)/(preyT+1e-5) ! grazing mortality of prey
     mGrz(j) = mGrz(j) + mGP
!    mGrz0(j)= mGrz0(j)+ mGP*exp(-((self%l0-lopt(i))**2-dl**2)/(2*sigma2(j))) ! offspring mortality

  ! update size gradient stores
     dlp(j)  = dlp(j)  - 3*dl*i13sig * mGP          ! size match to prey 
!   if (abs(dg_dB * dB_dl) .gt. 1.) write (*,'(A,4(F12.5))') 'dlpp=',dg_dB , dB_dl ,preyE,gross
!   if (abs(dlopt(i)* 3*dl*i13sig * dg_dB) .gt. 2.) write (*,'(A,2(I2),7(F12.5))') 'lpp=',i,j,dlpp(i),gross,dg_dB,dl,dlopt(i)* 3*dl*i13sig,lmsize(j), lopt(i)
   end do
  end do

!  loop over dynamic ctenophore populations 
  do i = 1, 2

!
! ----------  mortalities  -------------------
!
! integration result with Gaussian size distribution (cf. effective prey biomass)
!   pS      = exp(-(self%l0+1.0d0-lmsize(i))**2/rS)*srS
   rS      = 1.0d0 + 3. * sigma2(i)  ! "life-span"=1 : width of life-stage dependent mortality
   srS     = 1.0d0/sqrt(rS)
   eS      = exp(-((self%lA-lmsize(i))**2)/rS)*srS !lcrit self%lAlavg

!  how far way are juveniles from maturity?
!       physiological/starvation mortality 
! physiological/starvation status affects yield (Reeve1989)
! secondary production  
!   yfac    = 1.0d0/(1.0d0+0*starv)
   yfac    = 1.0d0
   Prod    = self%yield * yfac * graz(i)
! life-stage dependent mortality 
   argA    = (Prod-mort_R)/(2*self%mR+1e-4)
!    argA   = (Prod-mort_R)/(self%mR+1E-4)
   starv   = exp(-argA)!self%yield *

   mort_S0 = mS0 *starv 
   mort_S  = mort_S0 * (1.0d0-eS)
!    if (abs(mort_S) .gt. 13.5) write (*,'(A,1(I2),4(F12.4))') 'mS=',i,mort_S,mort_S0,eS,starv

! mortality due to parasites maximal at newly hetched larvae (Hirota1974 ,Greve)
   pS      = exp(-(self%lstarv -lmsize(i))**2/rS)*srS
! life-stage dependent mortality due to parasites
! fraction of large "meso"zooplakton as suitable parasite host 
!   f_tc    = exp(-(self%lA-lmsize(3))**2/rS)
   f_tc    = 1.0d0!mass(i)/(mass(i)+0.1d0)
!   fLc     = exp(-(loptA(i)-lmsize(3))**2/(1*sigma2(3)))
   fLc     = exp(-(loptA(i)-lmsize(3))**2/rS)
   fLc     = fLc * Temp_dep(3) * f_tc 
!   fLc     = fLc* exp(-(0.5-lmsize(3))**2/(2*sigma2(3)))
   m_host  = mass(i)+fLc*mass(3) + fLc*0.*var(ib)%B_Det

!   bcrit   = self%Bcrit/relDens(i+1) ! half-sturation constant TODDO: replace with mechanistic par
   bcrit   = self%Bcrit/relDens(i+1)

!   mort_P  = self%mP * (starv+pS) *m_host * var(ib)%B_Det/(1+0*relDens(i+1)) * Temp_dep(i) 
   mort_P  = self%mP * (starv*0+1.+pS) *m_host * var(ib)%Parasite * Temp_dep(i) *bcrit 
!* exp(-1*sBDet/250.0d0)!var(ib)%B_Det

! temperature dependent losses, with surface-to-volume scaling
!   mort_R  = self%mR * Temp_dep(i) * exp(-0.5*(lmsize(i)-lavg))
   mort_R  = self%mR * Temp_dep(i) * exp(-0.5*(lmsize(i)-lavg+lopt(i)))

!   mort_R  = self%mR * Temp_dep(i) * exp(0.5*(self%lA-lmsize(i)))! lcrit*(1.0 + fS)

! physical damage (turbulence); can be avoided by active swimming
!  mort_T0 = mT0/((1.0d0+exp(argA)) * (Temp_dep(i) +f_tc))
!   mort_T0 = mT0 * exp(0.5 - Temp_dep(i))
   mort_T0 = mT0 * starv 
!   mort_T0 = mT0
!   mort_T0 = mort_T0 * (var(ib)%Wind/6.25d0)**self%W_turb_exp  ! long-term mean 6.25m/s
!   mort_T  = mort_T0 * exp((lavg-lmsize(i))*0.5) 
!   mort_T  = mort_T0 * (exp(self%lA*0.5-lmsize(i)*0.5)+ exp(lmsize(i)*0.5))
   eS0     = exp(-((self%lA-lmsize(i))**2)/rS)
!   mort_T0 = mort_T0 * (1.0d0 + starv) * exp(-2*dlopt(i)) 
   mort_T  = mort_T0 * (1.0d0 - eS0) 
!   mort_T  = mort_T0  
! Dissipation ~/data/DeutscheBucht/getm/Diss_temp.eps : GETM, no winter/sturm 10^o factor ~2
! plot [-1:5][0.05:5] exp(-0.5*(x-0.5)),exp(-0.5*(x-0.5))+exp(-2+0.25*x)

!
! --------  energy/carbon partitioning to egg production/somatic growth  ------------
!
!  how far way are juveniles from maturity ? 
   argA    = (self%lA-lmsize(i))/(sqrt(2.d0)*sig(i))

   errf  = (1-exp(-argA*2.45d0))/(1+exp(-argA*2.45d0))

!   call self%errfunc(argA, errf) ! TODO: replace by more accurate err-function
! relative fraction of adults 
   fA      = 0.5d0*(1.0d0 - errf) 
!   if (abs(fA) .gt. 1.) write (*,'(A,1(I2),5(F12.5))') 'fA=',i,lmsize(i),sig(i) ,argA,errf, fA 

! size derivative of adult fraction
!   dfA_dl= sqrt(2.d0*3.1415)/sig(i) * eargA
! mean adult size
   eargA = exp(- argA*argA)
 !  if (eargA .gt. 1.2 .or. eargA .lt. 0.0001) write (*,'(A,1(I2),5(F12.5))') 'fA=',i,lmsize(i),sig(i) ,argA,eargA, fA 

   lm_adult = lmsize(i) + sig(i) / sqrt(2.d0*3.1415) * eargA / (abs(fA)+0.05d0)
!   lm_adult = lmsize(i) 

! fraction of adult secondary production allocated to recruitment
!   fR    = fS * yfac
  fR      = Temp_dep(i)
!   fR      = 0.5d0
! rate at which adults spawn new eggs
   recruit = fA * fR * Prod

! somatic growth : TODO: temperature dependency
   somgrwth    = Prod - recruit - mort_R  ! can become negative which is OK
   if(somgrwth .lt. 0.0d0 .and. lmsize(i) .lt. lavg ) somgrwth = 0.0d0 !exception: small organsisms; TODO: release?

! offspring mortality and long-term consequences; TODO: include realisic lag
! vulnerability proportional to stage duration (~ inverse temperature; food already in mort_S0 )
!   argA    = (mort_J-recruit)/self%mR
!   if (argA .gt. 10) argA = 10.0  ! to prevent numerical overflow 
!   fdejuv  = exp(argA-0)
!   fe      = self%mAJ * fdejuv/((fdejuv+1.0d0)*(Temp_dep(i)/f_tc+1.d0))
!   mort_AJ =  fe

!  sum of all mortality rates
   mort_sum= mort_R + mort_S + mGrz(i) + mort_P + mort_T
!    if (abs(mort_sum) .gt. 2.5) write (*,'(A,1(I2),4(F12.5))') 'mort=',i, mort_sum ,lmsize(i), mort_R ,mort_S
!
! ----------  stage and size dynamics  -------------------
!
   if (self%SizeDynOn) then
! egg production related part of size dynamics 
   init_dl = (self%l0 - lm_adult) * recruit
!     init_dl = (self%l0 - lmsize(i)) * recruit 
!    if (abs(init_dl) .gt. 200.) write (*,'(A,1(I2),5(F12.5))') 'init=',i, init_dl ,recruit,fA , fR , Prod
 
! somatic growth related part of size dynamics 
     som_dl  = somgrwth/3

! marginal size shift due to selective grazing at neutral kernel width
!   shifts prey distribution away from l_opt_pred, thus to lower mortality
     graz_dl = -sigma2(i) * dlp(i)

!  marginal size shift due to senescence
     sen_dl  = sigma2(i) * mort_S0 * eS * 2* (self%lA-lmsize(i))/rS 

!  marginal size shift due to respiration and turbulence (same scaling exponent)
!      turb_dl  = sigma2(i) * mort_T * 0.5
!    turb_dl  = sigma2(i) * mort_T0 * 0.5 * (exp(self%lA*0.5-lmsize(i)*0.5)- exp(lmsize(i)*0.5))
!    turb_dl  = sigma2(i) * mort_T0 * exp(-lmsize(i))
     turb_dl  = sigma2(i) * mort_T0 * eS0 *2* (self%lA-lmsize(i))/rS
!   mort_T  = mort_T0 * (exp((self%lA-lmsize(i))*0.5)+ exp(lmsize(i)*0.5))
     resp_dl  = sigma2(i) * mort_R * 0.5

!  marginal size shift due to density dependent mortality (parasites)
     paras_dl = -sigma2(i) * mort_P*pS/(starv*0+1.+pS+1.0E-4) *2 * (self%lA-lmsize(i))/rS !/(0*f_tc+pS+0*starv)

     prod_dl  = sigma2(i) * (Prod * al1(i) + self%yield*yfac*(dlpp(i)+dg_dl(i)))
!   if (abs(prod_dl) .gt. 1.) write (*,'(A,4(F12.5))') 'pdl=', prod_dl,sigma2(i),Prod * al1(i),self%yield*yfac*dlpp(i)

!  sum of productivity related size selective forces
     sum_dl  = init_dl + som_dl + prod_dl + resp_dl 

! boundary condition of offspring production and adaptive size shift

     argA    = (self%l0-lmsize(i))/(sqrt(2.d0)*sig(i))
     min_dl  = -recruit * exp(argA**2) * sig(i) / sqrt(2.d0*3.1415)
     if (sum_dl .lt. min_dl ) then 
       bound_dl = min_dl-sum_dl
     else
       bound_dl = 0.0
     endif
     sum_dl  = sum_dl + bound_dl

!  immigration  of mature individuals only
!     sum_dl  = sum_dl + self%immigr*(self%lA+2-lmsize(i))/var(ib)%B_Be

 !  sum of all size selective forces
     sum_dl  = sum_dl + graz_dl + sen_dl +  turb_dl + paras_dl
   else
     sum_dl  = 0.0d0
   endif
 
!   if (abs(sum_dl) .gt. 10. .and. ib .eq. 1) write (*,'(A,2(I2),5(F12.5))') 'dl=',i,ib,sum_dl , init_dl , som_dl , prod_dl,lmsize(i)
!   if (abs(Prod - mort_sum) .gt. 10. .and. ib .eq. 1) write (*,'(A,2(I2),6(F12.5))') 'dB=',i,ib,Prod , mort_sum,mort_S,mort_T,mort_P,mass(i)*1E3
!write (0,'(A,1(I2),3(F12.5))') 'i=',i,Prod,mort_sum,sum_dl
!write (0,'(A)',advance='no') ''

!#S__RHS
!#E__RHS
!---------- RHS for each state variable ----------
   if (i .eq. 1) then ! Beroe
! --- dynamics of Beroe biomass
    rhsv%B_Be = (Prod - mort_sum) * var(ib)%B_Be + self%immigr
! --- dynamics of Beroe mean log size
!    rhsv%l_Be = sum_dl+ self%immigr*(self%l0-lmsize(1))lcrit
    rhsv%l_Be = sum_dl 

   ! Export diagnostic variables
    if (ib.eq.1) then

  _SET_DIAGNOSTIC_(self%id_prod_Be, Prod)                   !step_integrated secondary production rate Beroe
  _SET_DIAGNOSTIC_(self%id_Mort_Be, mort_sum)               !step_integrated mortality rate of Beroe
  _SET_DIAGNOSTIC_(self%id_fA_Be, fA)                       !step_integrated relative propotion adults Beroe
  _SET_DIAGNOSTIC_(self%id_Imax_Be, Imax(1))                !step_integrated maximum ingestion rate adult Beroe
  _SET_DIAGNOSTIC_(self%id_al_Im, fLc)                   !al1(ib)step_integrated size scaling expoentent Imax 

    endif

   else  !  P.Pileus
! --- dynamics of P.Pileus biomass
    rhsv%B_Pp = (Prod - mort_sum) * var(ib)%B_Pp + self%immigr
! --- dynamics of P.Pileus mean log size
!    rhsv%l_Pp = sum_dl + self%immigr*(lcrit-lmsize(i))
    rhsv%l_Pp = sum_dl 
   ! Export diagnostic variables
    if (ib.eq.1) then
  _SET_DIAGNOSTIC_(self%id_prod_Pp, Prod)                   !step_integrated secondary production rate P pileus
  _SET_DIAGNOSTIC_(self%id_Mort_Pp, mort_sum)               !step_integrated mortality rate of P pileus
  _SET_DIAGNOSTIC_(self%id_fA_Pp, fA)                       !step_integrated relative propotion adults P pileus
  _SET_DIAGNOSTIC_(self%id_Imax_Pp, Imax(2))                !step_integrated maximum ingestion rate adult Beroe
  _SET_DIAGNOSTIC_(self%id_lopt_Be, lopt(1))                !step_integrated optimum prey size Beroe

  _SET_DIAGNOSTIC_(self%id_som_dl, som_dl)                  !step_integrated marginal size shift due to promotion
  _SET_DIAGNOSTIC_(self%id_init_dl, init_dl)                !step_integrated marginal size shift due to egg production
  _SET_DIAGNOSTIC_(self%id_graz_dl, graz_dl)                !step_integrated marginal size shift due to selective grazing
  _SET_DIAGNOSTIC_(self%id_sen_dl, sen_dl)                  !step_integrated marginal size shift due to starvation 
  _SET_DIAGNOSTIC_(self%id_turb_dl, turb_dl)                  !step_integrated marginal size shift due to physical damage 
  _SET_DIAGNOSTIC_(self%id_prod_dl, prod_dl)                !step_integrated marginal size shift due to production 
  _SET_DIAGNOSTIC_(self%id_resp_dl, resp_dl)                !step_integrated marginal size shift due to respiration 
  _SET_DIAGNOSTIC_(self%id_paras_dl, paras_dl)              !step_integrated marginal size shift due to parasitism 
  _SET_DIAGNOSTIC_(self%id_dl_prey, dlpp(i))                !step_integrated size difference to prey 
  _SET_DIAGNOSTIC_(self%id_dl_pred, dlp(i))                 !step_integrated size difference to pred 
  _SET_DIAGNOSTIC_(self%id_mort_P, mort_P)                  !step_integrated density dependent mortality - parasites
  _SET_DIAGNOSTIC_(self%id_mort_S, mort_S)                  !step_integrated physiological adult mortality rate
  _SET_DIAGNOSTIC_(self%id_mort_R, mort_R)                  !step_integrated temperature dependent mortality
  _SET_DIAGNOSTIC_(self%id_mort_G, mGrz(i))                  !step_integrated top-predation
  _SET_DIAGNOSTIC_(self%id_mort_J, mort_J)                  !step_integrated juvenile mortality
  _SET_DIAGNOSTIC_(self%id_mort_T, mort_T)                !step_integrated damaging effect of turbulence 
  _SET_DIAGNOSTIC_(self%id_somgrowth, somgrwth)             !step_integrated somatic growth rate 
  _SET_DIAGNOSTIC_(self%id_recruit, preyc(3))                !recruitstep_integrated egg production rate 
  _SET_DIAGNOSTIC_(self%id_mixBmass,starv)            !step_integrated mass exchange rate Coast-HR-Offshore (var(ib)%Wind/6.25d0)**self%W_turb_exp
  _SET_DIAGNOSTIC_(self%id_mixlsize, mass(3))           !dTrait(2,1)step_integrated trait exchange rate Coast-HR-Offshore
  _SET_DIAGNOSTIC_(self%id_Tdep, Temp_dep(i))                  !step_integrated Temperature dependence
    endif
  endif

!write (*,'(1(F10.6))')   ftd/ntd 
!#S__DIA
!#E__DIA
  end do
! common varibales:
! most simple detritus pool turnover dynamics 
!  rhsv%B_Det=  self%mS * mass_sum - self%rDet * Temp_dep(3) * var(ib)%B_Det
!  if (mass_sum .gt. 200.0d0) mass_sum = 200.0d0
! first the detritus change, as detrivory influences parasites
  sBDet     =   mass_sum - 0.5*Temp_dep(1) * var(ib)%B_Det

  rhsv%B_Det    = self%rDet * sBDet  ! 0.4444 mean of f_T 1962-2002 for Q10=2.5
!  rhsv%Parasite = self%rParasite*(var(ib)%B_Det*Temp_dep(3) - var(ib)%Parasite*2)
  rhsv%Parasite = self%rParasite*(var(ib)%B_Det*Temp_dep(3) - 0.5d0*var(ib)%Parasite/(0.001d0+Temp_dep(2)))
! + 0.0*Temp_dep(3)
! ------------------------------------------------------------------------------
!#S_ODE
!---------- ODE for each state variable ----------
  _SET_ODE_(self%id_B_Pp, rhsv%B_Pp UNIT)
  _SET_ODE_(self%id_l_Pp, rhsv%l_Pp UNIT)
  _SET_ODE_(self%id_B_Be, rhsv%B_Be UNIT)
  _SET_ODE_(self%id_l_Be, rhsv%l_Be UNIT)
  _SET_ODE_(self%id_B_Det, rhsv%B_Det UNIT)
  _SET_ODE_(self%id_Parasite, rhsv%Parasite UNIT)
!#E_ODE
  end do

   ! Leave spatial loops (if any)
   _FABM_LOOP_END_

   end subroutine do
!EOC

! ------------------------------------------------------------------------------
  pure real(rk) function grazkinetics(bcrit,preye)
   implicit none
   real(rk), intent(in)      :: bcrit, preye

   grazkinetics = 1.0d0-exp(-preye/bcrit)
   end function grazkinetics

! ------------------------------------------------------------------------------
! effective prey after integration over selection kernel  (Wirtz, MEPS 2014)
  pure real(rk) function prey_eff(dl2, prey)
   implicit none
   real(rk), intent(in)      :: dl2, prey
   prey_eff     = prey*sqrt(i13sig) * exp(-dl2*i13sig)
   end function prey_eff

! ------------------------------------------------------------------------------
! effective prey after integration over selection kernel  (Wirtz, MEPS 2014)
  pure real(rk) function prey_effc(dl2)
   implicit none
   real(rk), intent(in)      :: dl2
   prey_effc     = sqrt(i13sig) * exp(-dl2*i13sig)
   end function prey_effc

! ------------------------------------------------------------------------------
  pure real(rk) function grazrate(dl2,Imax0, bcrit, prey)
   implicit none
   real(rk), intent(in)      :: dl2, Imax0, bcrit, prey
 !   real(rk)   :: dl2
   grazrate = Imax0  * exp(-dl2) * grazkinetics(bcrit,prey) 

   end function grazrate

! ------------------------------------------------------------------------------
  pure real(rk) function f_temp(q10,T,T_c)
   implicit none
   real(rk), intent(in)      :: q10,T,T_c
!  real(rk)   :: q2
!   q2      = q10**2
!   f_temp  = 1.0d0/(q2 * exp(-T*q10/30)+ exp(-q2*(T-T_c)))
   f_temp  = 1.0d0/(exp(-(T-20.0d0)*0.1*log(q10))+ exp(-exp(1+q10)*(T-T_c)*0.1) )

   end function f_temp

! ------------------------------------------------------------------------------
subroutine mixing(self,Dil,Conci,Volo,Conco, dConci, dConco)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: Dil,Conci,Volo,Conco
 real(rk), intent(inout)   :: dConci, dConco
 real(rk)   ::  Conc_mix
! mixing coefficients 
 Conc_mix = (Conco*Volo+Conci)/(Volo + 1.0d0)
 
 dConci = Dil* ( Conco - Conc_mix ) *  Volo
 dConco = Dil* ( Conci - Conc_mix ) 
end subroutine mixing

subroutine errfunc(self,arg,errf)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: arg
 real(rk), intent(inout)   :: errf
 real(rk)   :: art

 errf  = (1-exp(-arg*2.45d0))/(1+exp(-arg*2.45d0))

end subroutine errfunc

!EOC
end module fabm_hzg_jelly
!:#endif
