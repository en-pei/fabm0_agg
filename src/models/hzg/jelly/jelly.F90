#include "fabm_driver.h"
#ifdef _FABM_F2003_
! --------------------------------------------
! Size- & distribution based ctenophore model
! kai wirtz Apr 2014
! --------------------------------------------
module fabm_hzg_jelly
!
! !USES:
  use fabm_types
  use fabm_driver
  implicit none

 !public flags for communication with fabm-driver/time-loop
  !character(len=80),   public      ::  jelly_timestr
  !integer,             public      ::  OutJellyRGR, CalcJellyRGR
  public grazkinetics

  private
 ! HZG model types
  !type type_diff
  ! real(rk) :: mu, dmudl, d2mudl2, dmudV, dsinkdl, dsinkdp, d2mudl2_d, dmu_d
  !end type
  integer   :: numb=1
  real(rk)  :: i13sig

!#SP0
!!----------------------------------------------------------------------
!! this code is generated by a parser  (conv_nml_fabm.c by kai wirtz)
!!----------------------------------------------------------------------
! --- HZG model types
type type_jelly_var
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be,B_Det
 real(rk) :: Cop,Temp,salt
end type
type type_jelly_rhs
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be,B_Det
end type
! standard fabm model types
type,extends(type_base_model),public :: type_hzg_jelly
type (type_state_variable_id)        :: id_B_Pp,id_l_Pp,id_B_Be,id_l_Be,id_B_Det
type (type_dependency_id)            :: id_Cop
type (type_dependency_id)            :: id_Temp
type (type_dependency_id)            :: id_salt
type (type_diagnostic_variable_id)   :: id_prod_Be, id_Mort_Be, id_fA_Be, id_Imax_Be, id_lopt_Be, id_prod_Pp, id_Mort_Pp, id_fA_Pp, id_Imax_Pp, id_mort_P, id_mort_S, id_mort_R, id_mort_G, id_mort_J, id_mort_T, id_somgrowth, id_recruit, id_paras_dl, id_som_dl, id_turb_dl, id_init_dl, id_graz_dl, id_sen_dl, id_prod_dl, id_resp_dl, id_dl_prey, id_dl_pred, id_al_Im, id_mixBmass, id_mixlsize, id_Tdep
real(rk) ::  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial, B_Det_initial
real(rk) ::  lA, l0, sigma, Imax_pot, yield, mR, mS, mP, mT, Q10, Tc, Bcrit, relCVDens, m_predBe, loptA_Pp, loptA_Be, sigmbc, immigr, rDet, T_turb, dil_CH, dil_HO, relV_O
real(rk) ::  eps, fCopGB, fTempGB
logical  ::  TransectOn, SizeDynOn, LowPassOn, OptionOn, MortSizeOn

contains
!   Model procedures
procedure :: initialize
procedure :: do
end type type_hzg_jelly

!
! !PRIVATE DATA MEMBERS:
 real(rk), parameter :: secs_pr_day = 86400.0_rk
!EOP
!!--------------------------------------------------------------------

contains
! !IROUTINE: Initialise the jelly model
!
! !INTERFACE:
subroutine initialize(self, configunit)
! !DESCRIPTION:
!  Here, the namelists are read and the variables exported
!  by the model are registered with FABM.
!
! !INPUT PARAMETERS:
class (type_hzg_jelly), intent(inout), target :: self
integer,                  intent(in)            :: configunit
!
! !LOCAL VARIABLES:
integer    :: namlst=19
!!------- Initial values of model jelly ------- 
!> \describepar{B_Pp_initial , B_\mathrm{Pp} , P.Pileus biomass, 5E-2 µg-C/L}
!> \describepar{l_Pp_initial , \ell_\mathrm{Pp} , P.Pileus mean log size, 1.2 log(ESD/mm)}
!> \describepar{B_Be_initial , B_\mathrm{Be} , Beroe biomass, 1E-4 µg-C/L}
!> \describepar{l_Be_initial , \ell_\mathrm{Be} , Beroe mean log size, 1.6 log(ESD/mm)}
!> \describepar{B_Det_initial , \ell_\mathrm{Be} , detritus, 10. µg-C/L}
real(rk)  :: B_Pp_initial ! P.Pileus biomass
real(rk)  :: l_Pp_initial ! P.Pileus mean log size
real(rk)  :: B_Be_initial ! Beroe biomass
real(rk)  :: l_Be_initial ! Beroe mean log size
real(rk)  :: B_Det_initial ! detritus
!> describepar{lA           , \ell_A           , adult ctenophore size        , 2. log(ESD/mm)}
!> describepar{l0           , \ell_0           , offspring size, -1.2 log(ESD/mm)}
!> describepar{sigma        , \sigma'        , log-size specific std deviation , 0.28 log(ESD/mm)^2}
!> describepar{Imax_pot     , I_\mathrm{max}^*     , maximum ingestion rate for ideal consumer, prey, T, and food , 173. 1/d}
!> describepar{yield        , y_0        , assimilation efficiency, 0.7 }
!> describepar{mR           , m_R^0           , temperature dependent, natural mortality rate , 0.8 1/d}
!> describepar{mS           , m_S^0           , physiological mortality under senescence , -0.1 1/d}
!> describepar{mP           , m_P^0           , density dependent mortality rate (parasites), 2.5E-4 1/d.µg-C/L}
!> describepar{mT           , m_{T}^0           , mortality due to physical damage (turbulence), -0.1 1/d}
!> describepar{Q10          , Q_{10}          , rate increase at 10C temperature rise, 3.2 }
!> describepar{Tc           , ^o$C] $T_c           , critical threshold temperature, 4.3 $^o$C}
!> describepar{Bcrit        , B^*        , minimal prey biomass (Holling-III) , 7. µg-C/L}
!> describepar{relCVDens    , R_\rho    , C-biovolume density ratio non-gelatinous/gelatinous plankton, 78. µg-C/L}
!> describepar{m_predBe     , m_\mathrm{top}     , loss rate of Beroe due to top-predator , 0. 1/d}
!> describepar{loptA_Pp     , \lcsize_\mathrm{opt,Pp}^A     , optimal prey size adult P.pileus , -0.4 }
!> describepar{loptA_Be     , \lcsize_\mathrm{opt,Be}^A     , optimal prey size adult Beroe , 1.8 }
!> describepar{sigmbc       , B_{\sigma}       , biomass below var size drop, 1E-3 µg-C/L}
!> describepar{immigr       , \epsilon_\mathrm{in}       , migration mass inflow rate , 1E-7 µg-C/L.d}
!> describepar{rDet         , r_\mathrm{Det}         , detritus turnover rate , 0.02 1/d}
!> describepar{T_turb       , ^o$C] $T_\mathrm{turb}       , correlation temperature-turbulence , 7.0 $^o$C}
!> describepar{dil_CH       ,        , Exchange rate Coast-HR, 0.35 1/d}
!> describepar{dil_HO       ,        , Exchange rate HR-Offshore, 0.1 1/d}
!> describepar{relV_O       ,        , relative volume Offshore box, 10. 1/d}
!> describepar{eps          ,           , unused, 1E-4 }
!> describepar{fCopGB       ,        , relative copepod abundance in offshore box, 0.5 }
!> describepar{fTempGB      ,       , relative temperature amplitude in offshore box, 0.8 }
!!------- Parameters from nml-list jelly_pars ------- 
real(rk)  :: lA           ! adult ctenophore size        
real(rk)  :: l0           ! offspring size
real(rk)  :: sigma        ! log-size specific std deviation 
real(rk)  :: Imax_pot     ! maximum ingestion rate for ideal consumer, prey, T, and food 
real(rk)  :: yield        ! assimilation efficiency
real(rk)  :: mR           ! temperature dependent, natural mortality rate 
real(rk)  :: mS           ! physiological mortality under senescence 
real(rk)  :: mP           ! density dependent mortality rate (parasites)
real(rk)  :: mT           ! mortality due to physical damage (turbulence)
real(rk)  :: Q10          ! rate increase at 10C temperature rise
real(rk)  :: Tc           ! critical threshold temperature
real(rk)  :: Bcrit        ! minimal prey biomass (Holling-III) 
real(rk)  :: relCVDens    ! C-biovolume density ratio non-gelatinous/gelatinous plankton
real(rk)  :: m_predBe     ! loss rate of Beroe due to top-predator 
real(rk)  :: loptA_Pp     ! optimal prey size adult P.pileus 
real(rk)  :: loptA_Be     ! optimal prey size adult Beroe 
real(rk)  :: sigmbc       ! biomass below var size drop
real(rk)  :: immigr       ! migration mass inflow rate 
real(rk)  :: rDet         ! detritus turnover rate 
real(rk)  :: T_turb       ! correlation temperature-turbulence 
real(rk)  :: dil_CH       ! Exchange rate Coast-HR
real(rk)  :: dil_HO       ! Exchange rate HR-Offshore
real(rk)  :: relV_O       ! relative volume Offshore box
!!------- Parameters from nml-list jelly_ctl ------- 
real(rk)  :: eps          ! unused
real(rk)  :: fCopGB       ! relative copepod abundance in offshore box
real(rk)  :: fTempGB      ! relative temperature amplitude in offshore box
!!------- Switches for configuring model structure -------
logical   :: TransectOn   ! mixing between coastal transect boxes
logical   :: SizeDynOn    ! life stage cycling enabled
logical   :: LowPassOn    ! filter high frequency in forcing
logical   :: OptionOn     ! generic
logical   :: MortSizeOn   ! size dependency in mortality

namelist /jelly_init/ &
  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial, B_Det_initial

namelist /jelly_pars/ &
  lA, l0, sigma, Imax_pot, yield, mR, mS, mP, mT, Q10, Tc, Bcrit, relCVDens, m_predBe, &
  loptA_Pp, loptA_Be, sigmbc, immigr, rDet, T_turb, dil_CH, dil_HO, relV_O

namelist /jelly_ctl/ &
  eps, fCopGB, fTempGB

namelist /jelly_switch/ &
  TransectOn, SizeDynOn, LowPassOn, OptionOn, MortSizeOn

B_Pp_initial = 5E-2_rk            ! µg-C/L
l_Pp_initial = 1.2_rk             ! log(ESD/mm)
B_Be_initial = 1E-4_rk            ! µg-C/L
l_Be_initial = 1.6_rk             ! log(ESD/mm)
B_Det_initial = 10._rk             ! µg-C/L
lA           = 2._rk              ! log(ESD/mm)
l0           = -1.2_rk            ! log(ESD/mm)
sigma        = 0.28_rk            ! log(ESD/mm)^2
Imax_pot     = 173._rk            ! 1/d
yield        = 0.7_rk             ! 
mR           = 0.8_rk             ! 1/d
mS           = -0.1_rk            ! 1/d
mP           = 2.5E-4_rk          ! 1/d.µg-C/L
mT           = -0.1_rk            ! 1/d
Q10          = 3.2_rk             ! 
Tc           = 4.3_rk             ! $^o$C
Bcrit        = 7._rk              ! µg-C/L
relCVDens    = 78._rk             ! µg-C/L
m_predBe     = 0._rk              ! 1/d
loptA_Pp     = -0.4_rk            ! 
loptA_Be     = 1.8_rk             ! 
sigmbc       = 1E-3_rk            ! µg-C/L
immigr       = 1E-7_rk            ! µg-C/L.d
rDet         = 0.02_rk            ! 1/d
T_turb       = 7.0_rk             ! $^o$C
dil_CH       = 0.35_rk            ! 1/d
dil_HO       = 0.1_rk             ! 1/d
relV_O       = 10._rk             ! 1/d
eps          = 1E-4_rk            ! 
fCopGB       = 0.5_rk             ! 
fTempGB      = 0.8_rk             ! 


!--------- read namelists --------- 
write(0,*) ' read namelists ....'
open(namlst,file='jelly_init.nml',status='old')
read(namlst,nml=jelly_init,err=90,end=99)
open(namlst,file='jelly_pars.nml',status='old')
read(namlst,nml=jelly_pars,err=91,end=100)
open(namlst,file='jelly_ctl.nml',status='old')
read(namlst,nml=jelly_ctl,err=92,end=101)
open(namlst,file='jelly_switch.nml',status='old')
read(namlst,nml=jelly_switch,err=93,end=102)
! Store parameter values in our own derived type
! NB: all rates must be provided in values per day,
! and are converted here to values per second.

!!------- logical parameters: switches  -------
call self%get_parameter(self%TransectOn,    'TransectOn',    default=TransectOn)
call self%get_parameter(self%SizeDynOn,     'SizeDynOn',     default=SizeDynOn)
call self%get_parameter(self%LowPassOn,     'LowPassOn',     default=LowPassOn)
call self%get_parameter(self%OptionOn,      'OptionOn',      default=OptionOn)
call self%get_parameter(self%MortSizeOn,    'MortSizeOn',    default=MortSizeOn)

!!------- model parameters from nml-list jelly_init ------- 
call self%get_parameter(self%B_Pp_initial ,'B_Pp_initial',  default=B_Pp_initial)
call self%get_parameter(self%l_Pp_initial ,'l_Pp_initial',  default=l_Pp_initial)
call self%get_parameter(self%B_Be_initial ,'B_Be_initial',  default=B_Be_initial)
call self%get_parameter(self%l_Be_initial ,'l_Be_initial',  default=l_Be_initial)
call self%get_parameter(self%B_Det_initial ,'B_Det_initial',  default=B_Det_initial)

!!------- model parameters from nml-list jelly_pars ------- 
call self%get_parameter(self%lA           ,'lA',            default=lA)
call self%get_parameter(self%l0           ,'l0',            default=l0)
call self%get_parameter(self%sigma        ,'sigma',         default=sigma)
call self%get_parameter(self%Imax_pot     ,'Imax_pot',      default=Imax_pot)
call self%get_parameter(self%yield        ,'yield',         default=yield)
call self%get_parameter(self%mR           ,'mR',            default=mR)
call self%get_parameter(self%mS           ,'mS',            default=mS)
call self%get_parameter(self%mP           ,'mP',            default=mP)
call self%get_parameter(self%mT           ,'mT',            default=mT)
call self%get_parameter(self%Q10          ,'Q10',           default=Q10)
call self%get_parameter(self%Tc           ,'Tc',            default=Tc)
call self%get_parameter(self%Bcrit        ,'Bcrit',         default=Bcrit)
call self%get_parameter(self%relCVDens    ,'relCVDens',     default=relCVDens)
call self%get_parameter(self%m_predBe     ,'m_predBe',      default=m_predBe)
call self%get_parameter(self%loptA_Pp     ,'loptA_Pp',      default=loptA_Pp)
call self%get_parameter(self%loptA_Be     ,'loptA_Be',      default=loptA_Be)
call self%get_parameter(self%sigmbc       ,'sigmbc',        default=sigmbc)
call self%get_parameter(self%immigr       ,'immigr',        default=immigr)
call self%get_parameter(self%rDet         ,'rDet',          default=rDet)
call self%get_parameter(self%T_turb       ,'T_turb',        default=T_turb)
call self%get_parameter(self%dil_CH       ,'dil_CH',        default=dil_CH)
call self%get_parameter(self%dil_HO       ,'dil_HO',        default=dil_HO)
call self%get_parameter(self%relV_O       ,'relV_O',        default=relV_O)

!!------- model parameters from nml-list jelly_ctl ------- 
call self%get_parameter(self%eps          ,'eps',           default=eps)
call self%get_parameter(self%fCopGB       ,'fCopGB',        default=fCopGB)
call self%get_parameter(self%fTempGB      ,'fTempGB',       default=fTempGB)

!!------- Register state variables  ------- 
call self%register_state_variable(self%id_B_Pp,  'B_Pp','µg-C/L','P.Pileus biomass B_Pp', &
   B_Pp_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_l_Pp,  'l_Pp','log(ESD/mm)','P.Pileus mean log size l_Pp', &
   l_Pp_initial, minimum=-2.0d0, no_river_dilution=.true. )
call self%register_state_variable(self%id_B_Be,  'B_Be','µg-C/L','Beroe biomass B_Be', &
   B_Be_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_l_Be,  'l_Be','log(ESD/mm)','Beroe mean log size l_Be', &
   l_Be_initial, minimum=-2.0d0, no_river_dilution=.true. )
call self%register_state_variable(self%id_B_Det, 'B_Det','µg-C/L','detritus B_Det', &
   B_Det_initial, minimum=_ZERO_, no_river_dilution=.true. )

!!------- Register diagnostic variables  ------- 
call self%register_diagnostic_variable(self%id_prod_Be, 'prod_Be','1/d', 'secondary production rate Beroe prod_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Be, 'Mort_Be','1/d', 'mortality rate of Beroe Mort_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Be,   'fA_Be','1/d', 'relative propotion adults Beroe fA_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Be, 'Imax_Be','1/d', 'maximum ingestion rate adult Beroe Imax_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_lopt_Be, 'lopt_Be','1/d', 'optimum prey size Beroe lopt_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_Pp, 'prod_Pp','1/d', 'secondary production rate P pileus prod_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Pp, 'Mort_Pp','1/d', 'mortality rate of P pileus Mort_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Pp,   'fA_Pp','1/d', 'relative propotion adults P pileus fA_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Pp, 'Imax_Pp','1/d', 'maximum ingestion rate adult Beroe Imax_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_P,  'mort_P','1/d', 'density dependent mortality - parasites mort_P', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_S,  'mort_S','1/d', 'physiological adult mortality rate mort_S', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_R,  'mort_R','1/d', 'temperature dependent mortality mort_R', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_G,  'mort_G','1/d', 'top-predation mort_G', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_J,  'mort_J','1/d', 'juvenile mortality mort_J', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_T,  'mort_T','1/d', 'damaging effect of turbulence mort_T', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_somgrowth, 'somgrowth','1/d', 'somatic growth rate  somgrowth', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_recruit, 'recruit','1/d', 'egg production rate  recruit', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_paras_dl, 'paras_dl','1/d', 'marginal size shift parasites paras_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_som_dl,  'som_dl','1/d', 'marginal size shift due to promotion som_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_turb_dl, 'turb_dl','1/d', 'marginal size shift due to physical damage turb_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_init_dl, 'init_dl','1/d', 'marginal size shift due to egg production init_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_graz_dl, 'graz_dl','1/d', 'marginal size shift due to selective grazing graz_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_sen_dl,  'sen_dl','1/d', 'marginal size shift due to starvation  sen_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_dl, 'prod_dl','1/d', 'marginal size shift due to production  prod_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_resp_dl, 'resp_dl','1/d', 'marginal size shift due to respiration  resp_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_prey, 'dl_prey','1/d', 'size difference to prey  dl_prey', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_pred, 'dl_pred','1/d', 'size difference to pred  dl_pred', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_al_Im,   'al_Im','1/d', 'size scaling expoentent Imax  al_Im', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixBmass, 'mixBmass','1/d', 'mass exchange rate Coast-HR-Offshore mixBmass', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixlsize, 'mixlsize','1/d', 'trait exchange rate Coast-HR-Offshore mixlsize', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Tdep,    'Tdep','1/d', 'Temperature dependence Tdep', &
  output=output_instantaneous)

!!------- Register environmental dependencies  ------- 
call self%register_dependency(self%id_Cop,standard_variables%downwelling_photosynthetic_radiative_flux)
call self%register_dependency(self%id_Temp,standard_variables%temperature)
call self%register_dependency(self%id_salt,standard_variables%practical_salinity)

! extra line included from parser var init_incl 
#define UNIT *1.1574074074E-5_rk

return

!!-------  if files are not found ...  
90 call self%fatal_error('jelly_init','Error reading namelist jelly_init.')
91 call self%fatal_error('jelly_init','Error reading namelist jelly_pars.')
92 call self%fatal_error('jelly_init','Error reading namelist jelly_ctl.')
93 call self%fatal_error('jelly_init','Error reading namelist jelly_switch.')
99 call self%fatal_error('jelly_init','Namelist jelly_init was not found in file.')
100 call self%fatal_error('jelly_init','Namelist jelly_pars was not found in file.')
101 call self%fatal_error('jelly_init','Namelist jelly_ctl was not found in file.')
102 call self%fatal_error('jelly_init','Namelist jelly_switch was not found in file.')

end subroutine initialize

!!----------------------------------------------------------------------
!!   end of section generated by parser 
!!----------------------------------------------------------------------
! #SP#"
!
!INTERFACE:
  subroutine do(self,_ARGUMENTS_DO_)
!
! !INPUT PARAMETERS:
  class (type_hzg_jelly),intent(in) :: self
  _DECLARE_ARGUMENTS_DO_
!
!LOCAL VARIABLES:

  type (type_jelly_var), dimension(3)       :: var
  type (type_jelly_rhs)       :: rhsv
  !type (type_diff)      :: diff,diff2
  !real(rk)              :: d2mudl2_d, dmu2=0.0_rk, mfac
!  type (type_environment),   intent(inout)  :: environment 
  real(rk) :: mort_S, mort_S0,mort_SJ, mort_R, mort_R0, mort_T0, mort_G
  real(rk) :: mort_J, mort_AJ, mort_P, mort_T, mort_sum, mass_sum
  real(rk) :: errf, argA, aa, rS, pS, pS0, eS, eS0, al0, yfac
  real(rk) :: somgrwth, recruit,lco, mGBe, f_tc, starv, dal_dl
  real(rk) :: prod_dl, sum_dl, resp_dl,paras_dl, turb_dl
  real(rk) :: graz_dl, som_dl, init_dl, sen_dl
  real(rk), dimension(2,numb) :: dConc,dTrait
  real(rk), dimension(3) :: Imax, al1, dlopt,lopt, graz,Temp_dep, Temp_dep0
  real(rk), dimension(3) :: mGrz, mGrz0, sig, sigma2, lmsize, dlp,dlpp, mass, relDens
  real(rk) :: dl0, dl, dl2, bcrit, prey, preyE, mGP, aS=2.0
  real(rk) :: fR, fA, dfA_dl, lm_adult, al, lprey, lcrit, lavg
  real(rk) :: gross, Prod, dg_dB, dB_dl, dg_dlY, srS, mS0, mT0
  integer  :: ib, ic, i, j
!  real(rk) :: inflow=2E-1, Adorm=2E-3

! !REVISION HISTORY:
!  Original author(s): Kai Wirtz

! !DESCRIPTION:
! Stage-based Pleurobrachia & Beroe   Model
!
!EOP
!-----------------------------------------------------------------------
!BOC
! argA  = 0.5*(self%lA+self%l0)/(sqrt(2.d0)*self%sigma)
! relative fraction of adhults 
! fA0    = 0.5d0*(1.0d0 - errf) 
! unify all mortalities
if(self%mS .lt. 0.0d0) then
   mS0 = self%mR
else
   mS0 = self%mS
endif
if(self%mT .lt. 0.0d0) then
   mT0 = self%mR
else
   mT0 = self%mT
endif

! ! self%mAJ = self%mR

   ! Enter spatial loops (if any)
_FABM_LOOP_BEGIN_

! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb

!#S_GET
!---------- GET for each state variable ----------
  _GET_(self%id_B_Pp, var(ib)%B_Pp)  ! P.Pileus biomass in µg-C/L
  _GET_(self%id_l_Pp, var(ib)%l_Pp)  ! P.Pileus mean log size in log(ESD/mm)
  _GET_(self%id_B_Be, var(ib)%B_Be)  ! Beroe biomass in µg-C/L
  _GET_(self%id_l_Be, var(ib)%l_Be)  ! Beroe mean log size in log(ESD/mm)
  _GET_(self%id_B_Det, var(ib)%B_Det)  ! detritus in µg-C/L
!#E_GET
   ! Retrieve current environmental conditions.
!#S_GED
  _GET_(self%id_Cop, var(ib)%Cop)  ! biomass from Greve data-set
  _GET_(self%id_Temp, var(ib)%Temp)  ! temperature HR
  _GET_(self%id_salt, var(ib)%salt)  ! salinity HR
!#E_GED

 end do
!
! ---------- set environmental conditions for each box  -------------------
!
!write (*,'(A,3(F10.3))') 'temp=',var(1)%Temp,var(2)%Temp,var(3)%Temp
! ib=1 HR   2: Coast  3:Offshore
! open water: less copepods, and reduced temperature fluctuation
!  var(2)%Cop  = 1.5 * var(2)%Cop
!  var(2)%Temp = -0.5 + 1.15*var(2)%Temp
! var(numb)%Cop  = self%fCopGB * var(numb)%Cop
! assuming a mean temperature of 10^oC
! var(numb)%Temp = (1.0d0-self%fTempGB)*10.0d0 + self%fTempGB*var(numb)%Temp

! f_tc  = 1.0d0/(exp(-(self%Tc-20.0d0)*0.1*log(self%Q10))+ 1.0d0 )
  f_tc  = 1.0d0/(exp(-(0-20.0d0)*0.1*log(self%Q10)) + 1.0d0)

! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb

!
! ---------- set specific variables for each population  -------------------
!
! set coefficient vectors over prey populations:  1: Beroe 2: Ppileus  3: Cops
  lmsize(1) = var(ib)%l_Be  ! mean body size of population
  lmsize(2) = var(ib)%l_Pp  ! 
  lmsize(3) = -0.7d0        ! small copepods dominate. ! TODO: include as forcing 
  sigma2(3) = 0.8d0         ! log-size variance of mesozooplakton
  mass(1)   = var(ib)%B_Be  ! biomass concentration
  mass(2)   = var(ib)%B_Pp
  mass(3)   = var(ib)%Cop * 1.0d0/(1.0d0+exp(1.0d0-var(ib)%salt))

  relDens(3)= 1.0d0         ! rel. C-biovolume density ratio of non-gelatinous plankton
  dlopt(1)  = (self%loptA_Be-self%l0)/(self%lA-self%l0) ! increase in l_opt; feeding mode development
  dlopt(2)  = (self%loptA_Pp-self%l0)/(self%lA-self%l0)
!  lopt(3)  = (-2.0-self%l0)/(self%lA-self%l0)
  lopt(3)   = self%l0
  Imax(3)   = 1.0d0
  Temp_dep(3) = f_temp(1.5d0, var(ib)%Temp, 0.0d0)

! re-gauge coefficient to apply  Imax-scaling of Wirtz JPR,2012 
!    log(1E3/80) converts from log(micro-m) to log(mm) but accounts for much lower C-density
  lco     = log(1E3/self%relCVDens)
! optimum size/stage with minimal life-stage dependent mortality 
  lcrit   = 0.5*(0.0d0 + self%lA + self%l0) 
!  lcrit   = self%lA  
  lavg    = 0.5*(2*self%lA + self%l0) 
!  loop over ctenophore populations:  1: Beroe 2: Ppileus 
  do i = 1, 2
    relDens(i)= self%relCVDens
    lopt(i)   = self%l0 + (lmsize(i)-self%l0)*dlopt(i) ! optimal prey size

! potential maximum ingestion rate depending on size, T, and feeding mode
   ! re-gauge log size to µm-scale used in Wirtz JPR,2012     log(1E3/80)=2.5
   !    converts from log(µm) to log(mm) but accounts for much lower C-density  
    al        = -0.4d0 * (lopt(i)-lmsize(i))
    dal_dl    = 0.4d0 * (1.0 - dlopt(i))
    Imax(i)   = self%Imax_pot * exp( al + (2-al)*(lopt(i)+lco) +(al-3)*(lmsize(i)+lco) )
!    al1(i)  = Temp_dep*(al-3) +Temp_dep*dlopt(i)*(2-al)
! size derivative of Imax-scaling
!    al1(i)    = (al-3) + dlopt(i)*(2-al)
    al1(i)    = (al-3) + dlopt(i)*(2-al) + dal_dl*(1.0d0 - lopt(i) + lmsize(i))
!    al1(i)  = (al-Temp_dep*3 + dlopt(i)*(Temp_dep*2-al))
! correction to prevent unrealistic Imax-size dependency (see Fig.4 Wirtz JPR 2013)
!    al0       = -1.d0
!    if (al1(i) .lt. al0) al1(i) = al0  

! temperature dependency for egg spawning, somatic growth and mortalities 
    Temp_dep(i) = f_temp(self%Q10 +lopt(i), var(ib)%Temp, self%Tc)
!  Temp_dep0= f_temp(self%Q10, var(ib)%Temp, 0.0d0)

! std of size distribution increases at large mean size and drops at very low number concentration
    rS        = sqrt(mass(i))/(sqrt(mass(i))+0.5d0*sqrt(self%sigmbc))
    sig(i)    = self%sigma * (0.*self%sigma + (lcrit*4+lmsize(i)))
! TODO: refine empirical relationship using Greve, Falkenhaug1996 or Finenko2003 data 
! sig(i) = self%sigma * (lmsize(i)*(2*self%lA-lmsize(i)))
    sigma2(i) = sig(i)*sig(i)*rS ! variance from std
! set accumulating stores to zero
    graz(i)   = 0.0d0
    dlpp(i)   = 0.0d0
  end do
  mass_sum  = 0.0d0
  do j = 1, 3
    dlp(j)    = 0.0d0
    mGrz(j)   = 0.0d0
    mGrz0(j)  = 0.0d0
    mass_sum  = mass_sum + mass(i)
  end do
!
! ---------- calculate RHS  -------------------
!
! ----------  loop over all trophic interactions  -------------------
!
!  loop over (ctenophore) predators
  do i = 1, 2
!  loop over prey populations:  1: Beroe 2: Ppileus 3: Cops
   do j = 1, 3
     i13sig  = 1.0d0/(1.0d0 + 3*sigma2(j))     ! 
     dl      = lmsize(j) - lopt(i)     ! size match to prey
     dl2     = 1.5d0*dl**2             ! feeding kernel argument, assumes "neutral" selectivity s=3/2
     preyE   = prey_eff(dl2,mass(j) )  ! effective prey mass after integration over selection kernel
     bcrit   = self%Bcrit/relDens(j)   ! half-sturation constant TODDO: replace with mechanistic par
     gross   = Temp_dep(i) * grazrate(dl2, Imax(i), bcrit, preyE) ! grazing rate

  ! update all flux stores
     graz(i) = graz(i) + gross
     mGP     = gross* mass(i)/(mass(j)+self%sigmbc) ! grazing mortality of prey
     mGrz(j) = mGrz(j) + mGP
     mGrz0(j)= mGrz0(j)+ mGP*exp(-((self%l0-lopt(i))**2-dl**2)/(2*sigma2(j))) ! offspring mortality

  ! update size gradient stores
     dlp(j)  = dlp(j)  - 3*dl*i13sig * mGP          ! size match to prey
     dg_dB   = gross/((exp(preyE/bcrit)-0.9d0)*bcrit) ! derivative with respect to prey biomass
     dB_dl   = dlopt(i)* 3*dl*i13sig *preyE! derivative of prey-mass with respect to consumer size (through optimal prey size dependency)
!if (i .eq. 1) then
     dlpp(i) = dlpp(i) + dg_dB * dB_dl  
!   if (abs(dg_dB * dB_dl) .gt. 1.) write (*,'(A,4(F12.5))') 'dlpp=',dg_dB , dB_dl ,preyE,gross

!   if (abs(dlopt(i)* 3*dl*i13sig * dg_dB) .gt. 2.) write (*,'(A,2(I2),7(F12.5))') 'lpp=',i,j,dlpp(i),gross,dg_dB,dl,dlopt(i)* 3*dl*i13sig,lmsize(j), lopt(i)

!else
!  if (j .eq. 2)  dlpp(i) = dlopt(i)* 3*dl/i13sig * dg_dB
!endif
   end do
  end do

!  loop over dynamic ctenophore populations 
  do i = 1, 2

! mortality due to parasites maximal at newly hetched larvae (Hirota1974 ,Greve)
!   pS      = exp(-(self%l0+1.0d0-lmsize(i))**2/rS)*srS
   rS      = 1.0d0 + 3. * sigma2(i)  ! "life-span"=1 : width of life-stage dependent mortality
   srS     = 1.0d0/sqrt(rS)
   pS      = exp(-(0*lcrit-lmsize(i))**2/rS)*srS
   pS0     = exp(-self%l0**2/rS)*srS
 !  eS    = 0
! life-stage dependent mortality due to parasites
!   mort_P  = self%mP * pS * (mass(i) + 0.004*var(ib)%B_Det) * var(ib)%B_Det !* Temp_dep(3)
   mort_P  = self%mP * pS * sqrt(mass(i)*var(ib)%B_Det) * var(ib)%B_Det* Temp_dep(i) 
!   if (i .eq. 1 .and. mort_P .gt. 0.05d0) mort_P = 0.05d0

! temperature dependent losses, with surface-to-volume scaling
   mort_R  = self%mR * Temp_dep(i) * exp(0.5*(lcrit-lmsize(i)))! lcrit*(1.0 + fS)
   mort_R0 = self%mR * Temp_dep(i) * exp(0.5*(lcrit-self%l0))! *(1.0 + fS)
!   mort_R0 = self%mR * Temp_dep(i) * exp(self%lA-self%l0)! *(1.0 + fS)

!
! ----------  mortalities  -------------------
!
! integration result with Gaussian size distribution (cf. effective prey biomass)
   eS      = exp(-(lavg-lmsize(i))**2/rS)*srS !lcrit self%lA
   eS0     = exp(-(lavg-self%l0)**2/rS)*srS  
 !  eS    = 0

!  how far way are juveniles from maturity? 
!       physiological/starvation mortality 

! physiological/starvation status affects yield (Reeve1989)
!  numerical loop 
   starv    = 1.0d0
   do j = 1, 3
! secondary production  
     yfac    = 1.0d0/(1.0d0+starv)
     Prod    = self%yield * yfac * graz(i)
! life-stage dependent mortality 
     argA   = (Prod-mort_R-mort_P)/(self%mR+self%mP)
     if (-argA .gt. 3) argA=-3.0d0 
     starv = exp(-argA)!self%yield *self%mR
!    if (abs(starv) .gt. 24.) write (*,'(A,1(I2),5(F12.3))') 'starv=',j,starv,Prod,yfac,mort_R,mort_P
   end do
   mort_S0 = mS0 *starv 
   mort_S  = mort_S0 * (1.0d0-eS)
    if (abs(mort_S) .gt. 13.5) write (*,'(A,1(I2),4(F12.4))') 'mS=',i,mort_S,mort_S0,eS,starv


!   if (var(ib)%l_Pp .lt. -0.7 .and. i .eq. 2) write (*,'(A,3(F12.5))') 'l1=',var(ib)%l_Pp,yfac,dlpp(i)
! physical damage (turbulence); can be avoided by active swimming
   mort_T0 = mT0 * exp(-var(ib)%Temp/self%T_turb) /(Temp_dep(i) +f_tc) 
!   mort_T0 = mT0 *starv/(1.0d0+starv)* exp(-(var(ib)%Temp-0.0)/self%T_turb) /(Temp_dep(i) +f_tc) 
   mort_T  = mort_T0 * (exp((lcrit-lmsize(i))*0.5) + exp(-self%lA*1+0.5*0.5*lmsize(i)))
! Dissipation ~/data/DeutscheBucht/getm/Diss_temp.eps : GETM, no winter/sturm 10^o factor ~2
! plot [-1:5][0.05:5] exp(-0.5*(x-0.5)),exp(-0.5*(x-0.5))+exp(-2+0.25*x)

!   f_tc  = 1.0d0/(exp(-(self%Tc-20.0d0)*0.1*log(self%Q10 + lopt(i)))+ 1.0d0 )
!
! --------  energy/carbon partitioning to egg production/somatic growth  ------------
!
!  how far way are juveniles from maturity ? 
   argA    = (self%lA-lmsize(i))/(sqrt(2.d0)*sig(i))

   errf  = (1-exp(-argA*2.45d0))/(1+exp(-argA*2.45d0))

!   call self%errfunc(argA, errf) ! TODO: replace by more accurate err-function
! relative fraction of adults 
   fA      = 0.5d0*(1.0d0 - errf) 
!   if (abs(fA) .gt. 1.) write (*,'(A,1(I2),5(F12.5))') 'fA=',i,lmsize(i),sig(i) ,argA,errf, fA 

! size derivative of adult fraction
!   dfA_dl= sqrt(2.d0*3.1415)/sig(i) * eargA
! mean adult size
!   lm_adult = lmsize(i) + sigma2(i) * dfA_dl / fA

! fraction of adult secondary production allocated to recruitment
!   fR    = fS * yfac
   fR      = Temp_dep(i)
! rate at which adults spawn new eggs
   recruit = fA * fR * Prod

! somatic growth : TODO: temperature dependency
   somgrwth    = Prod - recruit - mort_R  ! can become negative which is OK
   if(somgrwth .lt. 0.0d0 .and. lmsize(i) .lt. lcrit ) somgrwth = 0.0d0

! offspring mortality and long-term consequences; TODO: include realisic lag
   mort_J  = mGrz0(i) + mort_S0*(1.0d0-eS0) + mort_R0!+ self%mP *mass(i)*pS0 !+ 0*mort_R0

! vulnerability proportional to stage duration (~ inverse temperature; food already in mort_S0 )
!   argA    = (mort_J-recruit)/self%mR
!   if (argA .gt. 10) argA = 10.0  ! to prevent numerical overflow 
!   fdejuv  = exp(argA-0)
!   fe      = self%mAJ * fdejuv/((fdejuv+1.0d0)*(Temp_dep(i)/f_tc+1.d0))
!   mort_AJ =  fe

!  sum of all mortality rates
   mort_sum= mort_R + mort_S + mGrz(i) + mort_P + mort_T
!    if (abs(mort_sum) .gt. 2.5) write (*,'(A,1(I2),4(F12.5))') 'mort=',i, mort_sum ,lmsize(i), mort_R ,mort_S
!
! ----------  stage and size dynamics  -------------------
!
   if (self%SizeDynOn) then
! egg production related part of size dynamics 
!   init_dl = (self%l0 - lm_adult) * recruit
     init_dl = (self%l0 - lmsize(i)) * recruit 
    if (abs(init_dl) .gt. 200.) write (*,'(A,1(I2),5(F12.5))') 'init=',i, init_dl ,recruit,fA , fR , Prod
 
! somatic growth related part of size dynamics 
     som_dl  = somgrwth/3

! marginal size shift due to selective grazing at neutral kernel width
!   shifts prey distribution away from l_opt_pred, thus to lower mortality
     graz_dl = -sigma2(i) * dlp(i)

!  marginal size shift due to senescence
!    sen_dl  = sigma2(i) * (0*mort_R + mort_Sself%mS * exp(-2*gross/Imax)* dfA_dl )
!     if (self%OptionOn) then
     sen_dl  = sigma2(i) * mort_S0 * eS * 2* (lavg-lmsize(i))/rS 
!     else       sen_dl  = 0.0d0     endifself%lAlcrit

!  marginal size shift due to respiration and turbulence (same scaling exponent)
    if (self%OptionOn) then
!      turb_dl  = sigma2(i) * mort_T * 0.5
      turb_dl  = sigma2(i) * mort_T0 * 0.5* (exp((lcrit-lmsize(i))*0.5)- 0.5*exp(-self%lA*1+0.5*0.5*lmsize(i)))
    else
      turb_dl   = 0.0d0
    endif
    resp_dl  = sigma2(i) * mort_R * 0.5

!  marginal size shift due to density dependent mortality (parasites)
    paras_dl = -sigma2(i) * mort_P * 2* (0*lcrit-lmsize(i))/rS 

    prod_dl  = sigma2(i) * (Prod * al1(i) + self%yield*yfac*dlpp(i))
!   if (abs(prod_dl) .gt. 1.) write (*,'(A,4(F12.5))') 'pdl=', prod_dl,sigma2(i),Prod * al1(i),self%yield*yfac*dlpp(i)

!  sum of all size selctive forces
     sum_dl  = init_dl + som_dl + prod_dl + graz_dl + sen_dl + resp_dl + turb_dl + paras_dl

!  immigration  of mature individuals only
!     sum_dl  = sum_dl + self%immigr*(self%lA+2-lmsize(i))/var(ib)%B_Be

   else
     sum_dl  = 0.0d0
   endif
!   if (abs(sum_dl) .gt. 10. .and. ib .eq. 1) write (*,'(A,2(I2),5(F12.5))') 'dl=',i,ib,sum_dl , init_dl , som_dl , prod_dl,lmsize(i)
!   if (abs(Prod - mort_sum) .gt. 10. .and. ib .eq. 1) write (*,'(A,2(I2),6(F12.5))') 'dB=',i,ib,Prod , mort_sum,mort_S,mort_T,mort_P,mass(i)*1E3

!#S__RHS
!#E__RHS
!---------- RHS for each state variable ----------
   if (i .eq. 1) then ! Beroe
! --- dynamics of Beroe biomass
    rhsv%B_Be = (Prod - mort_sum) * var(ib)%B_Be + self%immigr
! --- dynamics of Beroe mean log size
!    rhsv%l_Be = sum_dl+ self%immigr*(self%l0-lmsize(1))lcrit
    rhsv%l_Be = sum_dl 

   ! Export diagnostic variables
    if (ib.eq.1) then

  _SET_DIAGNOSTIC_(self%id_prod_Be, Prod)                   !step_integrated secondary production rate Beroe
  _SET_DIAGNOSTIC_(self%id_Mort_Be, mort_sum)               !step_integrated mortality rate of Beroe
  _SET_DIAGNOSTIC_(self%id_fA_Be, fA)                       !step_integrated relative propotion adults Beroe
  _SET_DIAGNOSTIC_(self%id_Imax_Be, Imax(1))                !step_integrated maximum ingestion rate adult Beroe
    endif

   else  !  P.Pileus
! --- dynamics of P.Pileus biomass
    rhsv%B_Pp = (Prod - mort_sum) * var(ib)%B_Pp + self%immigr
! --- dynamics of P.Pileus mean log size
!    rhsv%l_Pp = sum_dl + self%immigr*(lcrit-lmsize(i))
    rhsv%l_Pp = sum_dl 
   ! Export diagnostic variables
    if (ib.eq.1) then
  _SET_DIAGNOSTIC_(self%id_prod_Pp, Prod)                   !step_integrated secondary production rate P pileus
  _SET_DIAGNOSTIC_(self%id_Mort_Pp, mort_sum)               !step_integrated mortality rate of P pileus
  _SET_DIAGNOSTIC_(self%id_fA_Pp, fA)                       !step_integrated relative propotion adults P pileus
  _SET_DIAGNOSTIC_(self%id_Imax_Pp, Imax(2))                !step_integrated maximum ingestion rate adult Beroe
  _SET_DIAGNOSTIC_(self%id_lopt_Be, lopt(1))                !step_integrated optimum prey size Beroe

  _SET_DIAGNOSTIC_(self%id_som_dl, som_dl)                  !step_integrated marginal size shift due to promotion
  _SET_DIAGNOSTIC_(self%id_init_dl, init_dl)                !step_integrated marginal size shift due to egg production
  _SET_DIAGNOSTIC_(self%id_graz_dl, graz_dl)                !step_integrated marginal size shift due to selective grazing
  _SET_DIAGNOSTIC_(self%id_sen_dl, sen_dl)                  !step_integrated marginal size shift due to starvation 
  _SET_DIAGNOSTIC_(self%id_turb_dl, turb_dl)                  !step_integrated marginal size shift due to physical damage 
  _SET_DIAGNOSTIC_(self%id_prod_dl, prod_dl)                !step_integrated marginal size shift due to production 
  _SET_DIAGNOSTIC_(self%id_resp_dl, resp_dl)                !step_integrated marginal size shift due to respiration 
  _SET_DIAGNOSTIC_(self%id_paras_dl, paras_dl)              !step_integrated marginal size shift due to parasitism 
  _SET_DIAGNOSTIC_(self%id_dl_prey, dlpp(i))                !step_integrated size difference to prey 
  _SET_DIAGNOSTIC_(self%id_dl_pred, dlp(i))                 !step_integrated size difference to pred 

  _SET_DIAGNOSTIC_(self%id_mort_P, mort_P)                  !step_integrated density dependent mortality - parasites
  _SET_DIAGNOSTIC_(self%id_mort_S, mort_S)                  !step_integrated physiological adult mortality rate
  _SET_DIAGNOSTIC_(self%id_mort_R, mort_R)                  !step_integrated temperature dependent mortality
  _SET_DIAGNOSTIC_(self%id_mort_G, mGrz(i))                  !step_integrated top-predation
  _SET_DIAGNOSTIC_(self%id_mort_J, mort_J)                  !step_integrated juvenile mortality
  _SET_DIAGNOSTIC_(self%id_mort_T, mort_T)                !step_integrated damaging effect of turbulence 
  _SET_DIAGNOSTIC_(self%id_somgrowth, somgrwth)             !step_integrated somatic growth rate 
  _SET_DIAGNOSTIC_(self%id_recruit, recruit)                !step_integrated egg production rate 
! 

  _SET_DIAGNOSTIC_(self%id_al_Im, 1.0d0/(1.0d0+exp(1.0d0-var(ib)%salt)))                   !step_integrated size scaling expoentent Imax 
  _SET_DIAGNOSTIC_(self%id_mixBmass, rhsv%B_Be)            !step_integrated mass exchange rate Coast-HR-Offshore
  _SET_DIAGNOSTIC_(self%id_mixlsize, sigma2(i))           !dTrait(2,1)step_integrated trait exchange rate Coast-HR-Offshore
  _SET_DIAGNOSTIC_(self%id_Tdep, Temp_dep(i))                  !step_integrated Temperature dependence
    endif
  endif

!write (*,'(1(F10.6))')   ftd/ntd 
!#S__DIA
!#E__DIA
  end do
! common varibales:
! most simple detritus pool turnover dynamics 
!  rhsv%B_Det=  self%mS * mass_sum - self%rDet * Temp_dep(3) * var(ib)%B_Det
!  if (mass_sum .gt. 200.0d0) mass_sum = 200.0d0
  rhsv%B_Det=   self%rDet * (mass_sum - Temp_dep(3) * var(ib)%B_Det)  ! 0.4444 mean of f_T 1962-2002 for Q10=2.5
! ------------------------------------------------------------------------------
!#S_ODE
!---------- ODE for each state variable ----------
  _SET_ODE_(self%id_B_Pp, rhsv%B_Pp UNIT)
  _SET_ODE_(self%id_l_Pp, rhsv%l_Pp UNIT)
  _SET_ODE_(self%id_B_Be, rhsv%B_Be UNIT)
  _SET_ODE_(self%id_l_Be, rhsv%l_Be UNIT)
  _SET_ODE_(self%id_B_Det, rhsv%B_Det UNIT)
!#E_ODE
  end do

   ! Leave spatial loops (if any)
   _FABM_LOOP_END_

   end subroutine do
!EOC

! ------------------------------------------------------------------------------
  pure real(rk) function grazkinetics(bcrit,preye)
   implicit none
   real(rk), intent(in)      :: bcrit, preye

   grazkinetics = 1.0d0-exp(-preye/bcrit)
   end function grazkinetics

! ------------------------------------------------------------------------------
! effective prey after integration over selection kernel  (Wirtz, MEPS 2014)
  pure real(rk) function prey_eff(dl2, prey)
   implicit none
   real(rk), intent(in)      :: dl2, prey
   prey_eff     = prey*sqrt(i13sig) * exp(-dl2*i13sig)
   end function prey_eff

! ------------------------------------------------------------------------------
  pure real(rk) function grazrate(dl2,Imax0, bcrit, prey)
   implicit none
   real(rk), intent(in)      :: dl2, Imax0, bcrit, prey
 !   real(rk)   :: dl2
   grazrate = Imax0  * exp(-dl2) * grazkinetics(bcrit,prey) 

   end function grazrate

! ------------------------------------------------------------------------------
  pure real(rk) function f_temp(q10,T,T_c)
   implicit none
   real(rk), intent(in)      :: q10,T,T_c
!  real(rk)   :: q2
!   q2      = q10**2
!   f_temp  = 1.0d0/(q2 * exp(-T*q10/30)+ exp(-q2*(T-T_c)))
   f_temp  = 1.0d0/(exp(-(T-20.0d0)*0.1*log(q10))+ exp(-exp(1+q10)*(T-T_c)*0.1) )

   end function f_temp

! ------------------------------------------------------------------------------
subroutine mixing(self,Dil,Conci,Volo,Conco, dConci, dConco)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: Dil,Conci,Volo,Conco
 real(rk), intent(inout)   :: dConci, dConco
 real(rk)   ::  Conc_mix
! mixing coefficients 
 Conc_mix = (Conco*Volo+Conci)/(Volo + 1.0d0)
 
 dConci = Dil* ( Conco - Conc_mix ) *  Volo
 dConco = Dil* ( Conci - Conc_mix ) 
end subroutine mixing

subroutine errfunc(self,arg,errf)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: arg
 real(rk), intent(inout)   :: errf
 real(rk)   :: art

 errf  = (1-exp(-arg*2.45d0))/(1+exp(-arg*2.45d0))

end subroutine errfunc

!EOC
end module fabm_hzg_jelly
#endif
