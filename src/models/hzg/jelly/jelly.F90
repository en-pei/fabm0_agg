#include "fabm_driver.h"
#ifdef _FABM_F2003_
! --------------------------------------------
! Size- & distribution based ctenophore model
! kai wirtz Apr 2014
! --------------------------------------------
module fabm_hzg_jelly
!
! !USES:
  use fabm_types
  use fabm_driver
  implicit none

 !public flags for communication with fabm-driver/time-loop
  !character(len=80),   public      ::  jelly_timestr
  !integer,             public      ::  OutJellyRGR, CalcJellyRGR
  public grazkinetics

  private
 ! HZG model types
  !type type_diff
  ! real(rk) :: mu, dmudl, d2mudl2, dmudV, dsinkdl, dsinkdp, d2mudl2_d, dmu_d
  !end type
  integer   :: numb=2
  real(rk)  :: i13sig

!#SP0
!!----------------------------------------------------------------------
!! this code is generated by a parser  (conv_nml_fabm.c by kai wirtz)
!!----------------------------------------------------------------------
! --- HZG model types
type type_jelly_var
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be,B_Det
 real(rk) :: Cop,Temp,salt
end type
type type_jelly_rhs
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be,B_Det
end type
! standard fabm model types
type,extends(type_base_model),public :: type_hzg_jelly
type (type_state_variable_id), dimension(2) :: id_B_Pp,id_l_Pp,id_B_Be,id_l_Be,id_B_Det
type (type_dependency_id)            :: id_Cop
type (type_dependency_id)            :: id_Temp
type (type_dependency_id)            :: id_salt
type (type_diagnostic_variable_id)   :: id_prod_Be, id_Mort_Be, id_fA_Be, id_Imax_Be, id_lopt_Be, id_prod_Pp, id_Mort_Pp, id_fA_Pp, id_Imax_Pp, id_mort_P, id_mort_S, id_mort_R, id_mort_G, id_mort_J, id_mort_AJ, id_somgrowth, id_recruit, id_paras_dl, id_som_dl, id_init_dl, id_graz_dl, id_sen_dl, id_prod_dl, id_resp_dl, id_dl_prey, id_dl_pred, id_al_Im, id_mixBmass, id_mixlsize, id_Tdep
real(rk) ::  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial, B_Det_initial
real(rk) ::  lA, l0, sigma, Imax_pot, yield, mR, mS, mP, mAJ, Q10, Tc, Bcrit, relCVDens, m_predBe, loptA_Pp, loptA_Be, sigmbc, immigr, rDet, dil_CH, dil_HO, relV_O
real(rk) ::  eps, fCopGB, fTempGB
logical  ::  TransectOn, SizeDynOn, LowPassOn, OptionOn, MortSizeOn

contains
!   Model procedures
procedure :: initialize
procedure :: do
procedure :: mixing
procedure :: errfunc
end type type_hzg_jelly

!
! !PRIVATE DATA MEMBERS:
 real(rk), parameter :: secs_pr_day = 86400.0_rk
!EOP
!!--------------------------------------------------------------------

contains
! !IROUTINE: Initialise the jelly model
!
! !INTERFACE:
subroutine initialize(self, configunit)
! !DESCRIPTION:
!  Here, the namelists are read and the variables exported
!  by the model are registered with FABM.
!
! !INPUT PARAMETERS:
class (type_hzg_jelly), intent(inout), target :: self
integer,                  intent(in)            :: configunit
!
! !LOCAL VARIABLES:
integer    :: namlst=19
!!------- Initial values of model jelly ------- 
!> \describepar{B_Pp_initial , B_\mathrm{Pp} , P.Pileus biomass, 0.005 µg-C/L}
!> \describepar{l_Pp_initial , \ell_\mathrm{Pp} , P.Pileus mean log size, 1.3 log(ESD/mm)}
!> \describepar{B_Be_initial , B_\mathrm{Be} , Beroe biomass, 0.001 µg-C/L}
!> \describepar{l_Be_initial , \ell_\mathrm{Be} , Beroe mean log size, 1.8 log(ESD/mm)}
!> \describepar{B_Det_initial , \ell_\mathrm{Be} , detritus, 0.1 µg-C/L}
real(rk)  :: B_Pp_initial ! P.Pileus biomass
real(rk)  :: l_Pp_initial ! P.Pileus mean log size
real(rk)  :: B_Be_initial ! Beroe biomass
real(rk)  :: l_Be_initial ! Beroe mean log size
real(rk)  :: B_Det_initial ! detritus
!> describepar{lA           , \ell_A           , adult ctenophore size        , 2. log(ESD/mm)}
!> describepar{l0           , \ell_0           , offspring size, -1.2 log(ESD/mm)}
!> describepar{sigma        , \sigma'        , std deviation of juvenile size, 0.27 log(ESD/mm)^2}
!> describepar{Imax_pot     , I_\mathrm{max}^*     , maximum ingestion rate for ideal consumer, prey, T, and food , 173. 1/d}
!> describepar{yield        , y'        , feeding yield , 0.7 }
!> describepar{mR           , m_R^0           , temperature dependent, natural mortality rate , 0.08 1/d}
!> describepar{mS           , m_S^0           , physiological mortality under senescence , 0.08 1/d}
!> describepar{mP           , m_P'^0           , density dependent mortality rate (parasites), 3E-3 1/d}
!> describepar{mAJ          , m_{AJ}^0          , mortality due to recruitment failure , 0.16 1/d.µg-C/L}
!> describepar{Q10          , Q_{10}          , rate increase at 10C temperature rise, 3.0 }
!> describepar{Tc           , T_c           , critical threshold temperature, 4.0 }
!> describepar{Bcrit        , B^*        , minimal prey biomass (Holling-III) , 10. µg-C/L}
!> describepar{relCVDens    , R_\rho    , C-biovolume density ratio non-gelatinous/gelatinous plankton, 80. µg-C/L}
!> describepar{m_predBe     , m_\mathrm{top}     , loss rate of Beroe due to top-predator , 0. 1/d}
!> describepar{loptA_Pp     , \lcsize_\mathrm{opt,Pp}^A     , optimal prey size adult P.pileus , -0.4 }
!> describepar{loptA_Be     , \lcsize_\mathrm{opt,Be}^A     , optimal prey size adult Beroe , 2.0 }
!> describepar{sigmbc       , B_{\sigma}       , biomass below var size drop, 3E-4 µg-C/L}
!> describepar{immigr       , \epsilon_\mathrm{in}       , migration mass inflow rate , 1E-7 µg-C/L.d}
!> describepar{rDet         , r_\mathrm{Det}         , detritus remineralisation rate , 0.04 1/d}
!> describepar{dil_CH       ,        , Exchange rate Coast-HR, 0.35 1/d}
!> describepar{dil_HO       ,        , Exchange rate HR-Offshore, 0.1 1/d}
!> describepar{relV_O       ,        , relative volume Offshore box, 10. 1/d}
!> describepar{eps          ,           , unused, 1E-4 }
!> describepar{fCopGB       ,        , relative copepod abundance in offshore box, 0.5 }
!> describepar{fTempGB      ,       , relative temperature amplitude in offshore box, 0.8 }
!!------- Parameters from nml-list jelly_pars ------- 
real(rk)  :: lA           ! adult ctenophore size        
real(rk)  :: l0           ! offspring size
real(rk)  :: sigma        ! std deviation of juvenile size
real(rk)  :: Imax_pot     ! maximum ingestion rate for ideal consumer, prey, T, and food 
real(rk)  :: yield        ! feeding yield 
real(rk)  :: mR           ! temperature dependent, natural mortality rate 
real(rk)  :: mS           ! physiological mortality under senescence 
real(rk)  :: mP           ! density dependent mortality rate (parasites)
real(rk)  :: mAJ          ! mortality due to recruitment failure 
real(rk)  :: Q10          ! rate increase at 10C temperature rise
real(rk)  :: Tc           ! critical threshold temperature
real(rk)  :: Bcrit        ! minimal prey biomass (Holling-III) 
real(rk)  :: relCVDens    ! C-biovolume density ratio non-gelatinous/gelatinous plankton
real(rk)  :: m_predBe     ! loss rate of Beroe due to top-predator 
real(rk)  :: loptA_Pp     ! optimal prey size adult P.pileus 
real(rk)  :: loptA_Be     ! optimal prey size adult Beroe 
real(rk)  :: sigmbc       ! biomass below var size drop
real(rk)  :: immigr       ! migration mass inflow rate 
real(rk)  :: rDet         ! detritus remineralisation rate 
real(rk)  :: dil_CH       ! Exchange rate Coast-HR
real(rk)  :: dil_HO       ! Exchange rate HR-Offshore
real(rk)  :: relV_O       ! relative volume Offshore box
!!------- Parameters from nml-list jelly_ctl ------- 
real(rk)  :: eps          ! unused
real(rk)  :: fCopGB       ! relative copepod abundance in offshore box
real(rk)  :: fTempGB      ! relative temperature amplitude in offshore box
!!------- Switches for configuring model structure -------
logical   :: TransectOn   ! mixing between coastal transect boxes
logical   :: SizeDynOn    ! life stage cycling enabled
logical   :: LowPassOn    ! filter high frequency in forcing
logical   :: OptionOn     ! generic
logical   :: MortSizeOn   ! size dependency in mortality
character(len=64)   :: sbname,cbname
integer   :: ib

namelist /jelly_init/ &
  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial, B_Det_initial

namelist /jelly_pars/ &
  lA, l0, sigma, Imax_pot, yield, mR, mS, mP, mAJ, Q10, Tc, Bcrit, relCVDens, m_predBe, &
  loptA_Pp, loptA_Be, sigmbc, immigr, rDet, dil_CH, dil_HO, relV_O

namelist /jelly_ctl/ &
  eps, fCopGB, fTempGB

namelist /jelly_switch/ &
  TransectOn, SizeDynOn, LowPassOn, OptionOn, MortSizeOn

B_Pp_initial = 0.005_rk           ! µg-C/L
l_Pp_initial = 1.3_rk             ! log(ESD/mm)
B_Be_initial = 0.001_rk           ! µg-C/L
l_Be_initial = 1.8_rk             ! log(ESD/mm)
B_Det_initial = 0.1_rk             ! µg-C/L
lA           = 2._rk              ! log(ESD/mm)
l0           = -1.2_rk            ! log(ESD/mm)
sigma        = 0.27_rk            ! log(ESD/mm)^2
Imax_pot     = 173._rk            ! 1/d
yield        = 0.7_rk             ! 
mR           = 0.08_rk            ! 1/d
mS           = 0.08_rk            ! 1/d
mP           = 3E-3_rk            ! 1/d
mAJ          = 0.16_rk            ! 1/d.µg-C/L
Q10          = 3.0_rk             ! 
Tc           = 4.0_rk             ! 
Bcrit        = 10._rk             ! µg-C/L
relCVDens    = 80._rk             ! µg-C/L
m_predBe     = 0._rk              ! 1/d
loptA_Pp     = -0.4_rk            ! 
loptA_Be     = 2.0_rk             ! 
sigmbc       = 3E-4_rk            ! µg-C/L
immigr       = 1E-7_rk            ! µg-C/L.d
rDet         = 0.04_rk            ! 1/d
dil_CH       = 0.35_rk            ! 1/d
dil_HO       = 0.1_rk             ! 1/d
relV_O       = 10._rk             ! 1/d
eps          = 1E-4_rk            ! 
fCopGB       = 0.5_rk             ! 
fTempGB      = 0.8_rk             ! 


!--------- read namelists --------- 
write(0,*) ' read namelists ....'
open(namlst,file='jelly_init.nml',status='old')
read(namlst,nml=jelly_init,err=90,end=99)
open(namlst,file='jelly_pars.nml',status='old')
read(namlst,nml=jelly_pars,err=91,end=100)
open(namlst,file='jelly_ctl.nml',status='old')
read(namlst,nml=jelly_ctl,err=92,end=101)
open(namlst,file='jelly_switch.nml',status='old')
read(namlst,nml=jelly_switch,err=93,end=102)
! Store parameter values in our own derived type
! NB: all rates must be provided in values per day,
! and are converted here to values per second.

!!------- logical parameters: switches  -------
call self%get_parameter(self%TransectOn,    'TransectOn',    default=TransectOn)
call self%get_parameter(self%SizeDynOn,     'SizeDynOn',     default=SizeDynOn)
call self%get_parameter(self%LowPassOn,     'LowPassOn',     default=LowPassOn)
call self%get_parameter(self%OptionOn,      'OptionOn',      default=OptionOn)
call self%get_parameter(self%MortSizeOn,    'MortSizeOn',    default=MortSizeOn)

!!------- model parameters from nml-list jelly_init ------- 
call self%get_parameter(self%B_Pp_initial ,'B_Pp_initial',  default=B_Pp_initial)
call self%get_parameter(self%l_Pp_initial ,'l_Pp_initial',  default=l_Pp_initial)
call self%get_parameter(self%B_Be_initial ,'B_Be_initial',  default=B_Be_initial)
call self%get_parameter(self%l_Be_initial ,'l_Be_initial',  default=l_Be_initial)
call self%get_parameter(self%B_Det_initial ,'B_Det_initial',  default=B_Det_initial)

!!------- model parameters from nml-list jelly_pars ------- 
call self%get_parameter(self%lA           ,'lA',            default=lA)
call self%get_parameter(self%l0           ,'l0',            default=l0)
call self%get_parameter(self%sigma        ,'sigma',         default=sigma)
call self%get_parameter(self%Imax_pot     ,'Imax_pot',      default=Imax_pot)
call self%get_parameter(self%yield        ,'yield',         default=yield)
call self%get_parameter(self%mR           ,'mR',            default=mR)
call self%get_parameter(self%mS           ,'mS',            default=mS)
call self%get_parameter(self%mP           ,'mP',            default=mP)
call self%get_parameter(self%mAJ          ,'mAJ',           default=mAJ)
call self%get_parameter(self%Q10          ,'Q10',           default=Q10)
call self%get_parameter(self%Tc           ,'Tc',            default=Tc)
call self%get_parameter(self%Bcrit        ,'Bcrit',         default=Bcrit)
call self%get_parameter(self%relCVDens    ,'relCVDens',     default=relCVDens)
call self%get_parameter(self%m_predBe     ,'m_predBe',      default=m_predBe)
call self%get_parameter(self%loptA_Pp     ,'loptA_Pp',      default=loptA_Pp)
call self%get_parameter(self%loptA_Be     ,'loptA_Be',      default=loptA_Be)
call self%get_parameter(self%sigmbc       ,'sigmbc',        default=sigmbc)
call self%get_parameter(self%immigr       ,'immigr',        default=immigr)
call self%get_parameter(self%rDet         ,'rDet',          default=rDet)
call self%get_parameter(self%dil_CH       ,'dil_CH',        default=dil_CH)
call self%get_parameter(self%dil_HO       ,'dil_HO',        default=dil_HO)
call self%get_parameter(self%relV_O       ,'relV_O',        default=relV_O)

!!------- model parameters from nml-list jelly_ctl ------- 
call self%get_parameter(self%eps          ,'eps',           default=eps)
call self%get_parameter(self%fCopGB       ,'fCopGB',        default=fCopGB)
call self%get_parameter(self%fTempGB      ,'fTempGB',       default=fTempGB)

!!------- Register state variables  ------- 
do ib = 1, 2
write (sbname, "(A,I1)") 'B_Pp',ib 
cbname = 'P.Pileus biomass ' // sbname
call self%register_state_variable(self%id_B_Pp(ib),sbname,'µg-C/L',cbname, &
   B_Pp_initial, minimum=_ZERO_, no_river_dilution=.true. )
write (sbname, "(A,I1)") 'l_Pp',ib 
cbname = 'P.Pileus mean log size ' // sbname
call self%register_state_variable(self%id_l_Pp(ib),sbname,'log(ESD/mm)',cbname, &
   l_Pp_initial, minimum=-2.0d0, no_river_dilution=.true. )
write (sbname, "(A,I1)") 'B_Be',ib 
cbname = 'Beroe biomass ' // sbname
call self%register_state_variable(self%id_B_Be(ib),sbname,'µg-C/L',cbname, &
   B_Be_initial, minimum=_ZERO_, no_river_dilution=.true. )
write (sbname, "(A,I1)") 'l_Be',ib 
cbname = 'Beroe mean log size ' // sbname
call self%register_state_variable(self%id_l_Be(ib),sbname,'log(ESD/mm)',cbname, &
   l_Be_initial, minimum=-2.0d0, no_river_dilution=.true. )
write (sbname, "(A,I1)") 'B_Det',ib 
cbname = 'detritus ' // sbname
call self%register_state_variable(self%id_B_Det(ib),sbname,'µg-C/L',cbname, &
   B_Det_initial, minimum=_ZERO_, no_river_dilution=.true. )
end do

!!------- Register diagnostic variables  ------- 
call self%register_diagnostic_variable(self%id_prod_Be, 'prod_Be','1/d', 'secondary production rate Beroe prod_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Be, 'Mort_Be','1/d', 'mortality rate of Beroe Mort_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Be,   'fA_Be','1/d', 'relative propotion adults Beroe fA_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Be, 'Imax_Be','1/d', 'maximum ingestion rate adult Beroe Imax_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_lopt_Be, 'lopt_Be','1/d', 'optimum prey size Beroe lopt_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_Pp, 'prod_Pp','1/d', 'secondary production rate P pileus prod_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Pp, 'Mort_Pp','1/d', 'mortality rate of P pileus Mort_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Pp,   'fA_Pp','1/d', 'relative propotion adults P pileus fA_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Pp, 'Imax_Pp','1/d', 'maximum ingestion rate adult Beroe Imax_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_P,  'mort_P','1/d', 'density dependent mortality - parasites mort_P', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_S,  'mort_S','1/d', 'physiological adult mortality rate mort_S', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_R,  'mort_R','1/d', 'temperature dependent mortality mort_R', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_G,  'mort_G','1/d', 'top-predation mort_G', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_J,  'mort_J','1/d', 'juvenile mortality mort_J', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_AJ, 'mort_AJ','1/d', 'effect of net juvenile mortality mort_AJ', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_somgrowth, 'somgrowth','1/d', 'somatic growth rate  somgrowth', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_recruit, 'recruit','1/d', 'egg production rate  recruit', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_paras_dl, 'paras_dl','1/d', 'marginal size shift parasites paras_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_som_dl,  'som_dl','1/d', 'marginal size shift due to promotion som_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_init_dl, 'init_dl','1/d', 'marginal size shift due to egg production init_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_graz_dl, 'graz_dl','1/d', 'marginal size shift due to selective grazing graz_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_sen_dl,  'sen_dl','1/d', 'marginal size shift due to starvation  sen_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_dl, 'prod_dl','1/d', 'marginal size shift due to production  prod_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_resp_dl, 'resp_dl','1/d', 'marginal size shift due to respiration  resp_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_prey, 'dl_prey','1/d', 'size difference to prey  dl_prey', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_pred, 'dl_pred','1/d', 'size difference to pred  dl_pred', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_al_Im,   'al_Im','1/d', 'size scaling expoentent Imax  al_Im', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixBmass, 'mixBmass','1/d', 'mass exchange rate Coast-HR-Offshore mixBmass', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixlsize, 'mixlsize','1/d', 'trait exchange rate Coast-HR-Offshore mixlsize', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Tdep,    'Tdep','1/d', 'Temperature dependence Tdep', &
  output=output_instantaneous)

!!------- Register environmental dependencies  ------- 
call self%register_dependency(self%id_Cop,varname_par)
call self%register_dependency(self%id_Temp,varname_temp)
call self%register_dependency(self%id_salt,varname_salt)

! extra line included from parser var init_incl 
#define UNIT *1.1574074074E-5_rk

return

!!-------  if files are not found ...  
90 call self%fatal_error('jelly_init','Error reading namelist jelly_init.')
91 call self%fatal_error('jelly_init','Error reading namelist jelly_pars.')
92 call self%fatal_error('jelly_init','Error reading namelist jelly_ctl.')
93 call self%fatal_error('jelly_init','Error reading namelist jelly_switch.')
99 call self%fatal_error('jelly_init','Namelist jelly_init was not found in file.')
100 call self%fatal_error('jelly_init','Namelist jelly_pars was not found in file.')
101 call self%fatal_error('jelly_init','Namelist jelly_ctl was not found in file.')
102 call self%fatal_error('jelly_init','Namelist jelly_switch was not found in file.')

end subroutine initialize

!!----------------------------------------------------------------------
!!   end of section generated by parser 
!!----------------------------------------------------------------------
! #SP#"
!
!INTERFACE:
  subroutine do(self,_ARGUMENTS_DO_)
!
! !INPUT PARAMETERS:
  class (type_hzg_jelly),intent(in) :: self
  _DECLARE_ARGUMENTS_DO_
!
!LOCAL VARIABLES:

  type (type_jelly_var), dimension(3)       :: var
  type (type_jelly_rhs)       :: rhsv
  !type (type_diff)      :: diff,diff2
  !real(rk)              :: d2mudl2_d, dmu2=0.0_rk, mfac
!  type (type_environment),   intent(inout)  :: environment 
  real(rk) :: mort_S, mort_S0,mort_SJ, mort_R, mort_RJ, mort_G
  real(rk) ::  mort_J, mort_AJ, mort_P, mort_sum, mass_sum
  real(rk) :: errf, argA, eargA, aa, rS, pS, pS0, eS, eS0, fS, fe, al0, yfac
  real(rk) :: somgrwth, recruit,lco, mGBe, f_tc
  real(rk) :: prod_dl, sum_dl, resp_dl,paras_dl
  real(rk) :: graz_dl, som_dl, init_dl, sen_dl
  real(rk), dimension(2,numb) :: dConc,dTrait
  real(rk), dimension(3) :: Imax, al1, dlopt,lopt, graz,Temp_dep, Temp_dep0
  real(rk), dimension(3) :: mGrz, mGrz0, sig, sigma2, lmsize, dlp,dlpp, mass, relDens
  real(rk) :: dl0, dl, dl2, bcrit, prey, preyE, mGP
  real(rk) :: fR, fA, fA0, fBe, dfA_dl, lm_adult, al, lprey, lcrit
  real(rk) :: gross, Prod, dg_dB0, dg_dB, dg_dlY,fdejuv, srS
  integer  :: ib, ic, i, j
!  real(rk) :: inflow=2E-1, Adorm=2E-3

! !REVISION HISTORY:
!  Original author(s): Kai Wirtz, Nusret Sevinc

! !DESCRIPTION:
! Stage-based Pleurobrachia & Beroe   Model
!
!EOP
!-----------------------------------------------------------------------
!BOC
! argA  = 0.5*(self%lA+self%l0)/(sqrt(2.d0)*self%sigma)
! call self%errfunc(argA, errf, eargA)
! relative fraction of adhults 
! fA0    = 0.5d0*(1.0d0 - errf) 

   ! Enter spatial loops (if any)
_FABM_LOOP_BEGIN_

! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb

!#S_GET
!---------- GET for each state variable ----------
  _GET_(self%id_B_Pp(ib), var(ib)%B_Pp)  ! P.Pileus biomass in µg-C/L
  _GET_(self%id_l_Pp(ib), var(ib)%l_Pp)  ! P.Pileus mean log size in log(ESD/mm)
  _GET_(self%id_B_Be(ib), var(ib)%B_Be)  ! Beroe biomass in µg-C/L
  _GET_(self%id_l_Be(ib), var(ib)%l_Be)  ! Beroe mean log size in log(ESD/mm)
  _GET_(self%id_B_Det(ib), var(ib)%B_Det)  ! detritus in µg-C/L
!#E_GET
   ! Retrieve current environmental conditions.
!#S_GED
  _GET_(self%id_Cop, var(ib)%Cop)  ! biomass from Greve data-set
  _GET_(self%id_Temp, var(ib)%Temp)  ! temperature HR
  _GET_(self%id_salt, var(ib)%salt)  ! salinity HR
!#E_GED

 end do
!
! ---------- set environmental conditions for each box  -------------------
!
!write (*,'(A,3(F10.3))') 'temp=',var(1)%Temp,var(2)%Temp,var(3)%Temp
! ib=1 HR   2: Coast  3:Offshore
! open water: less copepods, and reduced temperature fluctuation
!  var(2)%Cop  = 1.5 * var(2)%Cop
!  var(2)%Temp = -0.5 + 1.15*var(2)%Temp
 var(numb)%Cop  = self%fCopGB * var(numb)%Cop
! assuming a mean temperature of 10^oC
 var(numb)%Temp = (1.0d0-self%fTempGB)*10.0d0 + self%fTempGB*var(numb)%Temp

 if(self%TransectOn) then  ! unsused; TODO: check for plausibility of equations 
! exchange rate of mass HR-Offshore 
  call self%mixing(self%dil_HO, var(1)%B_Pp, self%relV_O,var(2)%B_Pp, dConc(1,1), dConc(1,2))
  call self%mixing(self%dil_HO, var(1)%B_Be, self%relV_O,var(2)%B_Be, dConc(2,1), dConc(2,2))

! exchange rate of trait  HR-Offshore 
  call self%mixing(self%dil_HO, var(1)%B_Pp*var(1)%l_Pp, self%relV_O,var(2)%B_Pp*var(2)%l_Pp, dTrait(1,1), dTrait(1,2))
!  dTrait(1,1) = dConci / var(1)%B_Pp
!  dTrait(1,2) = dConco / var(2)%B_Pp
  call self%mixing(self%dil_HO, var(1)%B_Be*var(1)%l_Be, self%relV_O,var(2)%B_Be*var(2)%l_Be, dTrait(2,1), dTrait(2,2))

 endif

 f_tc  = 1.0d0/(exp(-(self%Tc-20.0d0)*0.1*log(self%Q10))+ 1.0d0 )
   

! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb

!
! ---------- set specific variables for each population  -------------------
!
! set coefficient vectors over prey populations:  1: Beroe 2: Ppileus  3: Cops
  lmsize(1) = var(ib)%l_Be  ! mean body size of population
  lmsize(2) = var(ib)%l_Pp  ! 
  lmsize(3) = -0.7d0        ! small copepods dominate. ! TODO: include as forcing 
  sigma2(3) = 1.0d0         ! log-size variance of mesozooplakton
  mass(1)   = var(ib)%B_Be  ! biomass concentration
  mass(2)   = var(ib)%B_Pp
  mass(3)   = var(ib)%Cop
  relDens(3)= 1.0d0         ! rel. C-biovolume density ratio of non-gelatinous plankton
  dlopt(1)  = (self%loptA_Be-self%l0)/(self%lA-self%l0) ! increase in l_opt; feeding mode development
  dlopt(2)  = (self%loptA_Pp-self%l0)/(self%lA-self%l0)
!  lopt(3)  = (-2.0-self%l0)/(self%lA-self%l0)
  lopt(3)   = -1.2
  Imax(3)   = 1.5d0
  Temp_dep(3) = f_temp(self%Q10 + 0*lopt(3), var(ib)%Temp, self%Tc)
! re-gauge coefficient to apply  Imax-scaling of Wirtz JPR,2012 
!    log(1E3/80) converts from log(micro-m) to log(mm) but accounts for much lower C-density
  lco     = log(1E3/self%relCVDens)
! optimum size/stage with minimal life-stage dependent mortality 
  lcrit   = 0.5*(2 + self%lA + self%l0) 

!  loop over ctenophore populations:  1: Beroe 2: Ppileus 
  do i = 1, 2
    relDens(i)= self%relCVDens
    lopt(i)   = self%l0 + (lmsize(i)-self%l0)*dlopt(i) ! optimal prey size

! potential maximum ingestion rate depending on size, T, and feeding mode
   ! re-gauge log size to µm-scale used in Wirtz JPR,2012     log(1E3/80)=2.5
   !    converts from log(µm) to log(mm) but accounts for much lower C-density  
    al        = -0.4d0 * (lopt(i)-lmsize(i))
    Imax(i)   = self%Imax_pot * exp( al + (2-al)*(lopt(i)+lco) +(al-3)*(lmsize(i)+lco) )
!    al1(i)  = Temp_dep*(al-3) +Temp_dep*dlopt(i)*(2-al)
! size derivative of Imax-scaling
    al1(i)    = (al-3) + dlopt(i)*(2-al)
!    al1(i)  = (al-Temp_dep*3 + dlopt(i)*(Temp_dep*2-al))
! correction to prevent unrealistic Imax-size dependency (see Fig.4 Wirtz JPR 2013)
    al0       = -1.d0
    if (al1(i) .lt. al0) al1(i) = al0  

! temperature dependency for egg spawning, somatic growth and mortalities 
    Temp_dep(i) = f_temp(self%Q10 +lopt(i), var(ib)%Temp, self%Tc)
!  Temp_dep0= f_temp(self%Q10, var(ib)%Temp, 0.0d0)

! std of size distribution increases at large mean size and drops at very low number concentration
    rS        = sqrt(mass(i))/(sqrt(mass(i))+sqrt(self%sigmbc))
    sig(i)    = self%sigma * (self%sigma + (lcrit+lmsize(i))*rS)
! TODO: refine empirical relationship using Greve, Falkenhaug1996 or Finenko2003 data 
! sig(i) = self%sigma * (lmsize(i)*(2*self%lA-lmsize(i)))
    sigma2(i) = sig(i)*sig(i) ! variance from std
! set accumulating stores to zero
    graz(i)   = 0.0d0
    dlpp(i)   = 0.0d0
  end do
  mass_sum  = 0.0d0
  do j = 1, 3
    dlp(j)    = 0.0d0
    mGrz(j)   = 0.0d0
    mGrz0(j)  = 0.0d0
    mass_sum  = mass_sum + mass(i)
  end do
!
! ---------- calculate RHS  -------------------
!
! ----------  loop over all trophic interactions  -------------------
!
!  loop over (ctenophore) predators
  do i = 1, 2
!  loop over prey populations:  1: Beroe 2: Ppileus 3: Cops
   do j = 1, 3
     i13sig  = 1.0d0 + 3*sigma2(j)     ! 
     dl      = lmsize(j) - lopt(i)     ! size match to prey
     dl2     = 1.5d0*dl**2             ! feeding kernel argument, assumes "neutral" selectivity s=3/2
     preyE   = prey_eff(dl2,mass(j) )  ! effective prey mass after integration over selection kernel
     bcrit   = self%Bcrit/relDens(j)   ! half-sturation constant TODDO: replace with mechanistic par
     gross   = Temp_dep(i) * grazrate(dl2, Imax(i), bcrit, preyE) ! grazing rate

  ! update all flux stores
     graz(i) = graz(i) + gross
     mGP     = gross* mass(i)/(mass(j)+self%sigmbc) ! grazing mortality of prey
     mGrz(j) = mGrz(j) + mGP
     mGrz0(j)= mGrz0(j)+ mGP*exp(-((self%l0-lopt(i))**2-dl**2)/(2*sigma2(i))) ! offspring mortality

  ! update size gradient stores
     dlp(j)  = dlp(j)  - 3*dl/i13sig * mGP          ! size match to prey
     dg_dB   = gross/(1.0d0 + preyE/bcrit) / (preyE+1E-6)  ! derivative with respect to prey biomass
!if (i .eq. 1) then
    dlpp(i) = dlpp(i) + dlopt(i)* 3*dl/i13sig * dg_dB
!else
!  if (j .eq. 2)  dlpp(i) = dlopt(i)* 3*dl/i13sig * dg_dB
!endif
   end do
  end do

!  loop over dynamic ctenophore populations 
  do i = 1, 2

! mortality due to parasites maximal at newly hetched larvae (Hirota ,Greve)
!   pS      = exp(-(self%l0+1.0d0-lmsize(i))**2/rS)*srS
   pS      = exp(-(lcrit*0-lmsize(i))**2/rS)*srS
   pS0     = exp(-1.0d0)*srS
 !  eS    = 0
! life-stage dependent mortality due to parasites
   mort_P  = self%mP * pS * (mass(i) * var(ib)%B_Det) * Temp_dep(3)
 
! temperature dependent losses, with surface-to-volume scaling
   mort_R  = self%mR * Temp_dep(i) * exp(lcrit-lmsize(i))! *(1.0 + fS)
!   mort_RJ = self%mR * Temp_dep(i) * exp(self%lA-self%l0)! *(1.0 + fS)
   resp_dl = sigma2(i)* mort_R

! physiological/starvation status affects yield (Reeve1989)
   mort_S0 = exp(-(self%yield *graz(i)-mort_R-mort_P)/self%mR)!
   yfac    = 1.0d0/(1.0d0+mort_S0)
!   if (var(ib)%l_Pp .lt. -0.7 .and. i .eq. 2) write (*,'(A,3(F12.5))') 'l1=',var(ib)%l_Pp,yfac,dlpp(i)

! secondary production  
   Prod    = self%yield * yfac * graz(i)

!   f_tc  = 1.0d0/(exp(-(self%Tc-20.0d0)*0.1*log(self%Q10 + lopt(i)))+ 1.0d0 )

!
! --------  energy/carbon partitioning to egg production/somatic growth  ------------
!
!  how far way are juveniles from maturity ? 
   argA    = (self%lA-lmsize(i))/(sqrt(2.d0)*sig(i))
   call self%errfunc(argA, errf, eargA) ! TODO: replace by more accurate err-function
! relative fraction of adults 
   fA      = 0.5d0*(1.0d0 - errf) 
! size derivative of adult fraction
!   dfA_dl= sqrt(2.d0*3.1415)/sig(i) * eargA
! mean adult size
!   lm_adult = lmsize(i) + sigma2(i) * dfA_dl / fA

! fraction of adult secondary production allocated to recruitment
!   fR    = fS * yfac
   fR      = Temp_dep(i)
! rate at which adults spawn new eggs
   recruit = fA * fR * Prod

!
! ----------  mortalities  -------------------
!
!  how far way are juveniles from maturity? 
! physiological/starvation mortality 
!   mort_S0  = self%mS * exp(-rS*gross/Imax)!
   mort_S0 = self%mS * mort_S0 !*(1.0d0-Temp_dep(i))!

   rS      = 1.0d0 + 2. * sigma2(i)  ! "life-span"=1 : width of life-stage dependent mortality
   srS     = 1.0d0/sqrt(rS)
! integration result with Gaussian size distribution (cf. effective prey biomass)
   eS      = exp(-(lcrit-lmsize(i))**2/rS)*srS 
   eS0     = exp(-(lcrit-self%l0)**2)*srS  
 !  eS    = 0
! life-stage dependent mortality 
   mort_S  = mort_S0 * (1.0d0-eS)


! somatic growth : TODO: temperature dependency
   somgrwth    = Prod - recruit - mort_R  ! can become negative which is OK
   if(somgrwth .lt. 0.0d0 .and. lmsize(i) .lt. lcrit ) somgrwth = 0.0d0

! offspring mortality and long-term consequences; TODO: include realisic lag
   mort_J  = mGrz0(i) + mort_S0*(1.0d0-eS0) !+ self%mP *mass(i)*pS0 !+ 0*mort_RJ

! vulnerability proportional to stage duration (~ inverse temperature; food already in mort_S0 )
   argA    = (mort_J-recruit)/self%mS
   if (argA .gt. 10) argA=10.0  ! to prevent numerical overflow 
   fdejuv  = exp(argA-0)
   fe      = self%mAJ*  fdejuv/((fdejuv+1.0d0)*(Temp_dep(i)/f_tc+1.0d0))
!   fe      = self%mAJ*  fdejuv/((fdejuv+1.0d0))
!   mort_AJ = mGrz(i)*f0(i) + fe
   mort_AJ =  fe

!  sum of all mortality rates
   mort_sum= mort_R + mort_S + mGrz(i) + mort_AJ + mort_P

!
! ----------  stage and size dynamics  -------------------
!
   if (self%SizeDynOn) then
! egg production related part of size dynamics 
!   init_dl = (self%l0 - lm_adult) * recruit
     init_dl = (self%l0 - lmsize(i)) * recruit 
  
! somatic growth related part of size dynamics 
     som_dl  = somgrwth/3

! marginal size shift due to selective grazing at neutral kernel width
!   shifts prey distribution away from l_opt_pred, thus to lower mortality
     graz_dl = -sigma2(i) * dlp(i)

!  marginal size shift due to senescence
!    sen_dl  = sigma2(i) * (0*mort_R + mort_Sself%mS * exp(-2*gross/Imax)* dfA_dl )
     if (self%OptionOn) then
!     sen_dl  = sigma2(i) * rg*(rS-1.0d0)*fS*fS*eS*mort_S0
       sen_dl  = sigma2(i) * mort_S0 * eS * 2* (lcrit-lmsize(i))/rS 
       sen_dl  = sen_dl + mort_AJ*exp(-4*fA*fA)
     else
       sen_dl  = 0.0d0
     endif

!  marginal size shift due to density dependent mortality (parasites)
    paras_dl = -sigma2(i) * mort_P * pS * 2* (lcrit*0-lmsize(i))/rS 

    prod_dl  = sigma2(i) * (Prod * al1(i) + self%yield*yfac*dlpp(i))

!  sum of all size selctive forces
     sum_dl  = init_dl + som_dl + prod_dl + graz_dl + sen_dl + resp_dl
!  immigration  of mature individuals only
!     sum_dl  = sum_dl + self%immigr*(self%lA+2-lmsize(i))/var(ib)%B_Be

   else
     sum_dl  = 0.0d0
   endif

!#S__RHS
!#E__RHS
!---------- RHS for each state variable ----------
   if (i .eq. 1) then ! Beroe
! --- dynamics of Beroe biomass
    rhsv%B_Be = (Prod - mort_sum) * var(ib)%B_Be + self%immigr
! --- dynamics of Beroe mean log size
!    rhsv%l_Be = sum_dl+ self%immigr*(self%l0-lmsize(1))lcrit
    rhsv%l_Be = sum_dl 

   ! Export diagnostic variables
    if (ib.eq.1) then

  _SET_DIAGNOSTIC_(self%id_prod_Be, Prod)                   !step_integrated secondary production rate Beroe
  _SET_DIAGNOSTIC_(self%id_Mort_Be, mort_sum)               !step_integrated mortality rate of Beroe
  _SET_DIAGNOSTIC_(self%id_fA_Be, fA)                       !step_integrated relative propotion adults Beroe
  _SET_DIAGNOSTIC_(self%id_Imax_Be, Imax(1))                !step_integrated maximum ingestion rate adult Beroe
  _SET_DIAGNOSTIC_(self%id_lopt_Be, lopt(1))                !step_integrated optimum prey size Beroe
    endif

   else  !  P.Pileus
! --- dynamics of P.Pileus biomass
    rhsv%B_Pp = (Prod - mort_sum) * var(ib)%B_Pp + self%immigr
! --- dynamics of P.Pileus mean log size
!    rhsv%l_Pp = sum_dl + self%immigr*(lcrit-lmsize(i))
    rhsv%l_Pp = sum_dl 
   ! Export diagnostic variables
    if (ib.eq.1) then
  _SET_DIAGNOSTIC_(self%id_prod_Pp, Prod)                   !step_integrated secondary production rate P pileus
  _SET_DIAGNOSTIC_(self%id_Mort_Pp, mort_sum)               !step_integrated mortality rate of P pileus
  _SET_DIAGNOSTIC_(self%id_fA_Pp, fA)                       !step_integrated relative propotion adults P pileus
  _SET_DIAGNOSTIC_(self%id_Imax_Pp, Imax(2))                !step_integrated maximum ingestion rate adult Beroe
  _SET_DIAGNOSTIC_(self%id_mort_P, mort_P)                  !step_integrated density dependent mortality - parasites
  _SET_DIAGNOSTIC_(self%id_mort_S, mort_S)                  !step_integrated physiological adult mortality rate
  _SET_DIAGNOSTIC_(self%id_mort_R, mort_R)                  !step_integrated temperature dependent mortality
  _SET_DIAGNOSTIC_(self%id_mort_G, mGrz(i))                  !step_integrated top-predation
  _SET_DIAGNOSTIC_(self%id_mort_J, mort_J)                  !step_integrated juvenile mortality
  _SET_DIAGNOSTIC_(self%id_mort_AJ, mort_AJ)                !step_integrated effect of net juvenile mortality
  _SET_DIAGNOSTIC_(self%id_somgrowth, somgrwth)             !step_integrated somatic growth rate 
  _SET_DIAGNOSTIC_(self%id_recruit, recruit)                !step_integrated egg production rate 
  _SET_DIAGNOSTIC_(self%id_som_dl, som_dl)                  !step_integrated marginal size shift due to promotion
  _SET_DIAGNOSTIC_(self%id_init_dl, init_dl)                !step_integrated marginal size shift due to egg production
  _SET_DIAGNOSTIC_(self%id_graz_dl, graz_dl)                !step_integrated marginal size shift due to selective grazing
  _SET_DIAGNOSTIC_(self%id_sen_dl, sen_dl)                  !step_integrated marginal size shift due to starvation 
  _SET_DIAGNOSTIC_(self%id_prod_dl, prod_dl)                !step_integrated marginal size shift due to production 
  _SET_DIAGNOSTIC_(self%id_resp_dl, resp_dl)                !step_integrated marginal size shift due to respiration 
  _SET_DIAGNOSTIC_(self%id_paras_dl, paras_dl)              !step_integrated marginal size shift due to parasitism 
  _SET_DIAGNOSTIC_(self%id_dl_prey, dlpp(i))                !step_integrated size difference to prey 
  _SET_DIAGNOSTIC_(self%id_dl_pred, dlp(i))                 !step_integrated size difference to pred 
  _SET_DIAGNOSTIC_(self%id_al_Im, rhsv%l_Pp)                   !step_integrated size scaling expoentent Imax 
  _SET_DIAGNOSTIC_(self%id_mixBmass, rhsv%B_Be)            !step_integrated mass exchange rate Coast-HR-Offshore
  _SET_DIAGNOSTIC_(self%id_mixlsize, sigma2(i))           !dTrait(2,1)step_integrated trait exchange rate Coast-HR-Offshore
  _SET_DIAGNOSTIC_(self%id_Tdep, Temp_dep(i))                  !step_integrated Temperature dependence
    endif
  endif

!write (*,'(I3,2(F10.6))') ib,rhsv%AdPP,var(ib)%AdPP 
!#S__DIA
!#E__DIA
  end do
! common varibales:
! most simple detritus pool turnover dynamics 
!  rhsv%B_Det=  self%mS * mass_sum - self%rDet * Temp_dep(3) * var(ib)%B_Det
  rhsv%B_Det=   self%rDet * (mass_sum - var(ib)%B_Det)
! ------------------------------------------------------------------------------
!#S_ODE
!---------- ODE for each state variable ----------
  _SET_ODE_(self%id_B_Pp(ib), rhsv%B_Pp UNIT)
  _SET_ODE_(self%id_l_Pp(ib), rhsv%l_Pp UNIT)
  _SET_ODE_(self%id_B_Be(ib), rhsv%B_Be UNIT)
  _SET_ODE_(self%id_l_Be(ib), rhsv%l_Be UNIT)
  _SET_ODE_(self%id_B_Det(ib), rhsv%B_Det UNIT)
!#E_ODE
  end do

   ! Leave spatial loops (if any)
   _FABM_LOOP_END_

   end subroutine do
!EOC
! ------------------------------------------------------------------------------
  pure real(rk) function grazkinetics(bcrit,preye)
   implicit none
   real(rk), intent(in)      :: bcrit, preye
   real(rk)   :: hk
   hk  = 1.0d0
   if (preye .gt. bcrit*2E-1) then
     grazkinetics = preye**hk/(bcrit**hk + preye**hk)
   else
     grazkinetics = 0.0d0
   endif

   end function grazkinetics

! ------------------------------------------------------------------------------
! effective prey after integration over selection kernel  (Wirtz, MEPS 2014)
  pure real(rk) function prey_eff(dl2, prey)
   implicit none
   real(rk), intent(in)      :: dl2, prey
   prey_eff     = prey/sqrt(i13sig) * exp(-dl2/i13sig)
   end function prey_eff

! ------------------------------------------------------------------------------
  pure real(rk) function grazrate(dl2,Imax0, bcrit, prey)
   implicit none
   real(rk), intent(in)      :: dl2, Imax0, bcrit, prey
 !   real(rk)   :: dl2
   grazrate = Imax0  * exp(-dl2) * grazkinetics(bcrit,prey) 

   end function grazrate

! ------------------------------------------------------------------------------
  pure real(rk) function f_temp(q10,T,T_c)
   implicit none
   real(rk), intent(in)      :: q10,T,T_c
!  real(rk)   :: q2
!   q2      = q10**2
!   f_temp  = 1.0d0/(q2 * exp(-T*q10/30)+ exp(-q2*(T-T_c)))
   f_temp  = 1.0d0/(exp(-(T-20.0d0)*0.1*log(q10))+ exp(-exp(1+q10)*(T-T_c)*0.1) )

   end function f_temp

! ------------------------------------------------------------------------------
subroutine mixing(self,Dil,Conci,Volo,Conco, dConci, dConco)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: Dil,Conci,Volo,Conco
 real(rk), intent(inout)   :: dConci, dConco
 real(rk)   ::  Conc_mix
! mixing coefficients 
 Conc_mix = (Conco*Volo+Conci)/(Volo + 1.0d0)
 
 dConci = Dil* ( Conco - Conc_mix ) *  Volo
 dConco = Dil* ( Conci - Conc_mix ) 
end subroutine mixing

subroutine errfunc(self,arg,errf,ea2)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: arg
 real(rk), intent(inout)   :: errf, ea2
 real(rk)   :: art

 if(arg > 2.0d0) then 
   errf  = 1.0d0
 else
   if(arg < -2.0d0) then 
     errf  = -1.0d0
   else
     ea2 = exp(-arg*arg)
! error function approximation 
     art   = 1.0d0/(1.0d0+0.47047d0*arg)
     errf  = 1.0d0 - (0.3480242d0*art -0.0958798d0*art*art +0.7478556d0*art*art*art) * ea2
!   if (errf .lt. -0.99) write (*,'(A,3(F12.5))') 'err=',arg,art,errf
!       if (errf .lt. -0.99999) errf  = -0.99999d0
!       if (errf .gt.  0.99999) errf  =  0.99999d0
   endif
 endif
end subroutine errfunc

!EOC
end module fabm_hzg_jelly
#endif
